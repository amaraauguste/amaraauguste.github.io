<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/felipec.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  
  <!-- and it's easy to individually load additional languages -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
  
  <script>hljs.highlightAll();</script>
  <title>CISC 1115</title>
  <style>
  code {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 1em; /* Set the initial font size based on the default size */
      width: 92%; /* Set a width for the code block */
      max-width: 100%; /* Ensure the code block does not exceed the screen width */
    }

    @media only screen and (max-width: 600px) {
      code {
        font-size: 0.8em; /* Change font size for smaller screens */
      }
    }
    table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}

td, th {
  border: 1px solid black;
  text-align: left;
  padding: 8px;
}

tr:nth-child(1){
  background-color: #dddddd;
}

tr:nth-child(4), tr:nth-child(6), tr:nth-child(8), tr:nth-child(9) {
  background-color: lightyellow;
}

.structure tr:nth-child(even){
  background-color: rgb(241, 252, 255);
}
.structure tr:nth-child(odd){
  background-color: rgb(212, 244, 255);
}

.relation tr:nth-child(even){
  background-color: rgb(224, 235, 220);
}

.relation tr:nth-child(odd){
  background-color: rgb(245, 247, 244);
}

.truth tr:nth-child(even){
  background-color: rgb(247, 246, 244);
}

.truth tr:nth-child(odd){
  background-color: rgb(235, 225, 220);
}
    /* width */
    ::-webkit-scrollbar {
      width: 10px;
    }

    /* Track */
    ::-webkit-scrollbar-track {
      box-shadow: inset 0 0 5px grey; 
      border-radius: 10px;
    }
 
    /* Handle */
    ::-webkit-scrollbar-thumb {
      background: rgb(183, 147, 241); 
      border-radius: 10px;
    }

    /* Handle on hover */
    ::-webkit-scrollbar-thumb:hover {
      background: rgb(140, 111, 186); 
    }

    .backbutton {
      text-decoration: none;
      display: inline-block;
      padding: 8px 16px;
    }

    .backbutton:hover {
      background-color: #f678d0;
    }

    .previous {
      background-color: #f4c3e5;
      color: black;
    }

    .center {
      display: block;
      margin-left: auto;
      margin-right: auto;
      width: 80%;
    }

    header {
      color: black;
      margin: 10px;
      text-align: center;
      font-size: 1.8em;
      font-weight: thin;
    }

    #main-doc header {
      text-align: left;
      margin: 0px;
    }

    code {
        display: block;
        line-height: 2;
        padding: 15px;
        font-size: 26.5px;
        margin: 10px;
        border-radius: 5px;
      }

    @media only screen and (max-width: 400px) {
      #main-doc {
        margin-left: -10px;
      }

      code {
        margin-left: -20px;
        width: 100%;
        padding: 15px;
        padding-left: 10px;
        padding-right: 45px;
        min-width: 233px;
      }
    }

    body {
      font-family: "Lato", sans-serif;
    }

    #navbar {
      height: 100%;
      width: 180px;
      position: fixed;
      z-index: 1;
      top: 0;
      left: 0;
      background-color: #f4c3e5;
      overflow-x: hidden;
      padding-top: 20px;
    }

    #navbar a {
      padding: 6px 8px 6px 16px;
      text-decoration: none;
      font-size: 25px;
      color: #000000;
      display: block;
    }

    #navbar a:hover {
      color: #f1f1f1;
    }

    #main-doc {
      margin-left: 180px;
      /* Same as the width of the sidenav */
      font-size: 28px;
      /* Increased text to enable scrolling */
      padding: 0px 10px;
    }

    @media screen and (max-height: 450px) {
      #navbar {
        padding-top: 15px;
      }

      #navbar a {
        font-size: 18px;
      }
    }
  </style>
</head>

<body>
  <nav id="navbar">
    <header>CISC 1115</header>
    <hr />
    <a class="nav-link" href="#Intro" style="font-size: 22px">Intro to Programming</a>
    <a class="nav-link" href="#What_is_Java?" style="font-size: 21.659px">What is Java?</a>
    <a class="nav-link" href="#Hello_World" style="font-size: 22px">Hello World</a>
    <a class="nav-link" href="#Variables" style="font-size: 22px">Variables</a>
    <a class="nav-link" href="#Operators" style="font-size: 22px">Operators</a>
    <a class="nav-link" href="#Floating_Point" style="font-size: 22px">Floating-point Numbers</a>
    <a class="nav-link" href="#Math_Methods" style="font-size: 21.466px">Math Methods</a>
    <a class="nav-link" href="#Error_Types" style="font-size: 22px">Error Types</a>
    <a class="nav-link" href="#System" style="font-size: 22px">System Class</a>
    <a class="nav-link" href="#Datatypes" style="font-size: 22px">Data Types</a>
    <a class="nav-link" href="#Input" style="font-size: 22px">Reading Input</a>
    <a class="nav-link" href="#Constants" style="font-size: 22px">Literals and Constants</a>
    <a class="nav-link" href="#Program" style="font-size: 22px">Putting it all Together</a>
    <a class="nav-link" href="#Program_Structure" style="font-size: 22px">Program Structure</a>
    <a class="nav-link" href="#Files" style="font-size: 22px">Using Files</a>
    <a class="nav-link" href="#Relational_Operators" style="font-size: 22px">Relational Operators</a>
    <a class="nav-link" href="#Logical_Operators" style="font-size: 22px">Logical Operators</a>
    <a class="nav-link" href="#Conditional_Statements" style="font-size: 22px">Conditional Statements</a>
    <a class="nav-link" href="#Chaining_and_Nesting" style="font-size: 22px">Chaining and Nesting</a>
    <a class="nav-link" href="#Flag_Variables" style="font-size: 22px">Flag Variables</a>
    <a class="nav-link" href="#Validating_Input" style="font-size: 22px">Validating Input</a>
    <a class="nav-link" href="#Switch_Statements" style="font-size: 22px">Switch Statements</a>
    <a class="nav-link" href="#char_Data_Type" style="font-size: 22px">The char<br>Data Type</a>
    <a class="nav-link" href="#Loops" style="font-size: 22px">Loops</a>
    <a class="nav-link" href="#Characters" style="font-size: 22px">Characters</a>
    <a class="nav-link" href="#The_Character_Class" style="font-size: 22px">The Character Class</a>
    <a class="nav-link" href="#Strings" style="font-size: 22px">Strings</a>
    <a class="nav-link" href="#Methods" style="font-size: 22px">Methods</a>
    <a class="nav-link" href="#Arrays" style="font-size: 22px">Arrays</a>
    <!--
      
    
    <a class="nav-link" href="#Files" style="font-size: 22px">Using Files</a>
      
    -->
    
    <!--add more later-->

    <a class="nav-link" href="#Reference" style="font-size: 22px">Reference</a>
    <a href="https://amaraauguste.github.io/courses/cisc1115.html" class="previous backbutton"
      style="font-size: 22px">&laquo; Back</a>
      <br><br><br><br><br><br><br><br><br><br>
  </nav>
  <main id="main-doc">
    <!-- WEEK 1 NOTES -->
    <!-- WEEK 1 DAY 1-->
    <section class="main-section" id="Intro">
      <br />
      <header><b>Intro to Programming</b></header>
      <article>
      <p>
        In this class, we will write programs.
        <br /><br />
        But first, what is a program?
        <br /><br />
        A <b>program</b> is a sequence of instructions that specifies how to
        perform a computation. <br /><br />

        Every program you've
        ever used, no matter how complicated, is made up of small instructions that
        look much like the following:
      </p>
      <ul>
        <li>
          <b>input:</b> get data from the keyboard, a file, a sensor, or some other device
        </li>
        <br />
        <li>
          <b>output:</b> display data on the screen, or send data to a file or other device.
        </li>
        <br />
        <li>
          <b>math:</b> perform basic mathematical operations like addition and division.
        </li>
        <br />
        <li>
          <b>decisions:</b> check for certain conditions and execute the appropriate code
        </li>
        <br />
        <li>
          <b>repetition:</b> perform some action repeatedly, usually with some variation.
        </li>
      </ul>
      <p>We can think of <b>programming</b> as the process of:
        <i>breaking down a large, complex task into smaller and smaller subtasks.</i>
        <br><br>
        The process continues until the subtasks are simple enough to be performed with
        the basic instructions provided by the computer.
      </p>
      </article>
      <br />
      <header>What is Computer Science?</header>
      <article>
        <p>
          One of the most interesting aspects of writing programs is deciding <i><b>how</b></i> to
          solve a particular problem, especially when there are multiple solutions.
          <br /><br />

          In order to determine which way is best for a given situation,
          we need techniques for describing and analyzing solutions formally.
        </p>
        <p>
          <b>Computer science</b> is the science of algorithms, including their discovery and
          analysis.
          <br /><br />
          An <b>algorithm</b> is a sequence of steps that specifies how to solve a
          problem.
        <ul>
          <li>Some algorithms are faster than others, and some use less space
            in computer memory.</li>
        </ul>
        </p>
        <p>
          Designing algorithms and writing code is difficult and error-prone.
          <br><br>
          For historical reasons, programming errors are called <b>bugs</b>, and the process of tracking them down and
          correcting them is called <b>debugging</b>.
        </p>
      </article>
        <br />
        <header>Programming Languages</header>
        <article>
          <p>
            The programming language you will learn in this class is <b>Java</b>, which is a high-level language.
            <br> <br>
            A <b>high-level language</b> is any programming language that enables development of a program
            in a much more <b>user-friendly programming context and is generally independent of the computer's hardware
              architecture.</b>
            <br><br>
            Other high-level languages you may have heard of include:
          <ul>
            <li>Python</li>
            <li>C and C++</li>
            <li>Ruby</li>
            <li>JavaScript</li>
          </ul>
          Before they can run, programs in high-level languages have to be translated
          into a <b>low-level language</b>, also called “machine language”.
          <br><br>
          This translation takes some time, which is a small disadvantage of high-level languages.
          </p>
          <p>
            High-level languages have two advantages:
          <ol>
            <li>It is much <b>easier</b> to program in a high-level language.</li>
            <ul>
              <li> Programs take
                less time to write, they are shorter and easier to read, and they are more
                likely to be correct.</li>
            </ul>
            <br>
            <li>High-level languages are <b>portable</b>, meaning they can run on different
              kinds of computers with few or no modifications.</li>
            <ul>
              <li>Low-level programs
                can only run on one kind of computer, and have to be rewritten to run
                on another.
              </li>
            </ul>
          </ol>
          Two kinds of programs translate high-level languages into low-level languages:
          <b>interpreters</b> and <b>compilers</b>
          <ul>
            <li>An <b>interpreter</b> reads a high-level program and
              executes it, meaning that it does what the program says.
              It processes the program a little at a time, alternately reading lines and performing computations</li>
            <br>
            <li>A <b>compiler</b> reads the entire program and translates it completely
              before the program starts running. In this context, the high-level program is called the <b>source
                code</b>, and the translated program is called the object
              code or the executable. Once a program is compiled, you can execute it
              repeatedly without further translation. As a result, <b>compiled programs often
                run faster than interpreted programs.</b>
            </li>
          </ul>
          </p>
        </article>
        <br />
        <hr />
    </section>
    <section class="main-section" id="What_is_Java?">
      <br />
      <header><b>What is Java?</b></header>
      <article>
        <p>
          As aforementioned, Java is a high-level, class-based, object-oriented programming
          language and software platform that runs on billions of devices,
          including notebook computers, mobile devices, gaming consoles,
          medical devices and many others. The rules and syntax of Java are
          based on the C and C++ languages.
        </p>
        <p>Here are some specific examples of real world applications that use Java: </p>
        <ul>
          <li>LinkedIn</li>
          <li>Minecraft</li>
          <li>Amazon Web Services (AWS)</li>
        </ul>
        <p>To create an application using Java, you will need:</p>
        <ul>
          <li>
            to download and install the Java Development Kit (JDK),
            <a href="https://www.oracle.com/java/technologies/downloads/">which is available for Windows, macOS, and
              Linux</a>.
          </li>
          <br />
          <li>
            A command-line interface (CLI) on your computer that allows you to
            create and delete files, run programs, and navigate through
            folders and files (<b>On a Mac, it's called Terminal, and on Windows, it's Command
              Prompt</b>) OR an integrated development environment (IDE) - a software
            application that helps programmers develop software code
            efficiently by combining capabilities such as software editing,
            building, testing, and packaging in an easy-to-use application,
            such as
            <a href="https://www.eclipse.org/downloads/packages/">Eclipse</a>,
            <a href="https://netbeans.apache.org/front/main/download/index.html">NetBeans</a>,
            <a href="https://www.jetbrains.com/idea/download/?section=windows">IntelliJ</a>, <a
              href="https://drjava.sourceforge.net/">DrJava</a>, etc.
          </li>
        </ul>
        <p>
          You write the program in the Java programming language, then a
          compiler turns the program into Java bytecode—the instruction set
          for the Java Virtual Machine (JVM) that is a part of the Java
          runtime environment (JRE). Java bytecode runs without modification
          on any system that supports JVMs, allowing your Java code to be run
          anywhere. The Java software platform consists of the JVM, the Java
          API, and a complete development environment. The JVM parses and runs
          (interprets) the Java bytecode.
          <br><br>
          <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/JavaProcess.png?raw=true"
            alt="Java Process">
          <br><br>
          The Java API consists of an
          extensive set of libraries including basic objects, networking and
          security functions; Extensible Markup Language (XML) generation; and
          web services. Taken together, the Java language and the Java
          software platform create a powerful, proven technology for
          enterprise software development.
        </p>
      </article>
      <br />
      <hr />
    </section>
    <section class="main-section" id="Hello_World">
      <br />
      <header><b>Hello World</b></header>
      <article>
        <p>
          To start programming in Java, we can write a simple program that
          outputs "Hello, World!" on the screen. Since it's a very simple
          program, it's often used to introduce a new programming language to
          a newbie! 😃
        </p>
        <p>Let's explore how Java "Hello, World!" program works:</p>
        <pre><code class="language-java">// Our First Program
public class HelloWorld {
    public static void main(String [] args) {
        System.out.println("Hello, World!");
    }
}</code></pre>
        <br />
        <p><b>How does the "Hello, World!" program work?</b></p>
        <ol>
          <li>
            In Java, any line starting with // is a <b>single-line</b> comment
            (We will learn more about multi-line comments in a bit). Comments
            are intended for users reading the code to understand the intent
            and functionality of the program. It is completely ignored by the
            Java compiler (an application that translates Java program to Java
            bytecode that computer can execute).
          </li>
          <br />
          <li>
            Every application begins with a class definition. In this
            particular program, HelloWorld is the name of the class and the
            name of the class should match the filename in Java.
          </li>
          <br />
          <li>
            Next is the main method. Every application in Java must contain
            the main method. The Java compiler starts executing the code from
            the main method, and it's mandatory in each of our executable Java
            programs. The signature of the main method in Java is:
            <br /><br />
            <text style="margin-left: 10px">public static void main(String [] args) { ... }</text>
          </li>
          <br />
          <li>
            Lastly, we have a print statement. It prints the text Hello,
            World! to standard output (your screen). The text inside the
            quotation marks is called a String <i>literal</i> in Java.
            <b>Notice the print statement is inside the main function, which
              is inside the class definition.</b>
          </li>
        </ol>
      </article>
      <br />
      <header>Comments</header>
      <article>
        <p> Comments have no effect on
          the execution of the program, but they make it easier for other programmers
          (and yourself!) to understand what you meant to do and how the program works.</p>
        <p>There are three types of comments:</p>
        <ul style="list-style: none;">
          <li>// single line comments</li>
          <br>
          <li>/*<br>
            multiline comments<br>
            */ </li>
          <br>
          <li>/** <br>
            multiline Documentation Comments
            to create formal documentation using Javadoc
            <br>
            */
          </li>
        </ul>
      </article>
      <br />
      <hr />
    </section>
    <section class="main-section" id="Variables">
      <br />
      <header><b>Variables</b></header>
      <p>
        You may have seen variables before (Think back to high school algebra!
        Solving for X, etc.)
        <br /><br />
        In programming, a variable is a location in memory (storage area) that
        holds data.
        <br /><br />
        (For now just one value at a time ... we'll come back to this later)
        <br /><br />
        To indicate the storage area, each variable is given a unique name.
        The names of variables, called <b>identifiers</b>, conform to the
        following rules:
      </p>
      <ul>
        <li>
          Identifiers CANNOT be a keyword (ex. keywords like int, for, class,
          etc CANNOT be used as a variable name (or identifier) as they are
          part of the Java programming language syntax
        </li>
        <br />
        <li>
          Identifiers are case-sensitive (ex. age, AGE, Age, etc. are all
          valid identifiers and can all exist within the same program,
          although NOT RECOMMENDED 😡)
        </li>
        <br />
        <li>
          Identifiers can be made up of a sequence of letters and digits.
          However,
          <b>it must begin with a letter, '$' (dollar sign) or '_'
            (underscore).</b>
          (It is convention to start an identifier with a letter) The first
          letter of an identifier CANNOT be a digit.
        </li>
        <br />
        <li>
          Identifiers CANNOT contain whitespaces, nor symbols such as @, #,
          and so on.
        </li>
        <br />
        <li>Examples of <b>VALID</b> ✔️ identifiers:</li>
        <ul>
          <li>player1</li>
          <li>score</li>
          <li>level</li>
          <li>highScore</li>
          <br />
        </ul>
        <li>Examples of <b>INVALID</b> ❌ identifiers:</li>
        <ul>
          <li>pl@yer</li>
          <li>1score</li>
          <li>class</li>
          <li>highest Score</li>
        </ul>
      </ul>
      <br />
      <header>Declaring Variables</header>
      <br />
      <article>
        It is easy to declare a variable!
        <br />
        <p>
          First we identify the necessary keyword for the variable datatype.
          For example, a whole number should be declared as an integer type
          known as int while a decimal number should be declared as a float or
          double.
          <br /><br />
          <pre><code class="language-java"><text>int score = 42;</text> </code></pre>
          <br />
          This syntax can be used to declare both local and global variables
          (we'll talk about this more later 😉).
        </p>
        <p>
          In the previous example, we have assigned value to the variable
          during declaration -- this is known as initialization, because we
          assign an initial value to a variable.
          <br /><br />
          However, we can also declare variables and assign variables
          separately.
        </p>
        <p>For example:</p>
        <pre><code class="language-java">int score;
score = 42;</code></pre>
        <p>When you declare a variable, you create a named storage location.
          <br><br>
          When you make an assignment to a variable, you update its value.
        </p>
        <p>
          The value of a variable can be modified throughout the program
          (that's what makes it a <i>variable</i>, opposed to a
          <i>literal</i>)
        </p>
        <p>For example:</p>
        <pre><code class="language-java">int score = 0;
//more code to be added here
score = 42;</code></pre>
        <p>Here, initially, we set the score to 0.</p>
        <p>
          Later (after some more code -- not yet specified) we changed it to
          42.
        </p>
        <p>
          It is important to remember, however, that we CANNOT change the data
          type of a variable in Java within the same scope (we'll discuss
          scope a bit more later, for now just think of our scope limited to
          the main method)
        </p>
      </article>
      <br />
      <header>Printing Variables</header>
      <article>
        <p>
          We can display the value of a variable using print or println.
          <br /><br />
          <pre><code class="language-java">int score = 42;
//What should be printed below?
System.out.println(score);</code></pre>
          <br />
          When we talk about displaying a variable, we generally mean the <b>value</b> of the variable.
          <br><br>
          To display the name of a variable, you have to put it in quotes.
        </p>
      </article>
      <br/>
      <header>Variable Scope</header>
            <article>
               <p>
                The scope of a variable is the part of the program where the variable is accessible.
               </p>
               <p>
                In general, a set of curly brackets { } defines a scope. 
                <br><br>
                <b>A variable declared inside pair of brackets “{” and “}” in a method is only accessible within the scope of the brackets only.</b>
                (This will make more sense when we explore conditional statements, loops, methods, etc.)
               </p>
            </article>
      <br />
      <header>Global/Member Variables</header>
            <article>
               <p>
                We can also declare variables directly inside the class (outside any specific method -- we will revisit this once we begin writing more methods). 
                <br><br>
                <b>These variables can be directly accessed anywhere in class.</b>
               </p>
            </article>
      <br />
      <hr />
    </section>
    <section class="main-section" id="Operators">
      <br />
      <header><b>Java Operators</b></header>
      <article>
        <p>
          Operators are symbols that perform operations on variables and
          values. For example, we know that + is an operator used for
          addition, while * is an operator used for multiplication.
        </p>
        <p>Operators in Java can be classified into the following types:</p>
        <ol>
          <b>
            <li>Arithmetic Operators</li>
          </b>
          <ul>
            <li>
              Arithmetic operators are used to perform arithmetic operations
              on variables and data.
            </li>
            <li>The various arithmetic operators we use include:</li>
            <ul style="list-style-type: none">
              <li>+ (Addition, e.g. a + b)</li>
              <li>- (Subtraction, e.g. a - b)</li>
              <li>* (Multiplication, e.g. a * b)</li>
              <li>/ (Division, e.g. a / b)</li>
              <li>% (Modulus -Remainder after division, e.g. a % b)</li>
              <li>++ (Increment, e.g. a++ or ++a)</li>
              <li>-- (Decrement, e.g. a-- or --a)</li>
            </ul>
          </ul>
          <br />
          <b>
            <li>Assignment Operators</li>
          </b>
          <ul>
            <li>
              Assignment operators are used in Java to assign values to
              variables.
            </li>
            <li>A few assignment operators available in Java include:</li>
            <ul style="list-style-type: none">
              <li>= (Assignment, e.g. a = b)</li>
              <li>
                += (Additional assignment, e.g. a += b is equivalent to a = a
                + b)
              </li>
              <li>
                we can also write assignment operators for other arithmetic
                operations such as subtraction, multiplication, division,
                modulus, etc.
              </li>
            </ul>
          </ul>
          <br />
          <b>
            <li>Relational (or Comparison) operators</li>
          </b>
          <ul>
            <li>
              Relational/Comparison operators are used to compare two values
              (or variables). The values returned from comparison are known as
              boolean values and will either be <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text>.
            </li>
            <li>
              A few relational/comparison operators available in Java include:
            </li>
            <ul style="list-style-type: none">
              <li>== (Equal to, e.g. a == b)</li>
              <li>!= (Not equal to, e.g. a != b)</li>
              <li>> (Greater than, e.g. a > b)</li>
              <li>
                < (Less than, e.g. a < b)</li>
              <li>>= (Greater than or equal to, e.g. a >= b)</li>
              <li>
                <= (Less than or equal to, e.g. a <=b)</li>
            </ul>
          </ul>
          <br />
          <b>
            <li>Logical Operators</li>
          </b>
          <ul>
            <li>
              Logical operators are used to determine the logic (whether a
              statement is <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text>) between 
              variables or values.
            </li>
            <li>A few logical operators available in Java include:</li>
            <ul style="list-style-type: none">
              <li>
                && (Logical and - returns <text style="color:blue"><b>true</b></text> if both statements are true,
                e.g. a < 5 && b < 5) </li>
              <li>
                || (Logical or - returns <text style="color:blue"><b>true</b></text> if one of the statements is
                true, e.g. a < 5 || b < 5) </li>
              <li>
                ! (Logical not - reverses the result, returns <text style="color:blue"><b>false</b></text> if the
                result is true, e.g. !(a < 5 && b < 5))) </li>
            </ul>
          </ul>
          <br />
          <b>
            <li>Unary Operators</li>
          </b>
          <ul>
            <li>
              Unary operators are operators that need only one operand to
              perform any operation, such as: increment, decrement, negation,
              etc. It consists of various arithmetic, logical and other
              operators that operate on a single operand.
            </li>
            <li>A few unary operators available in Java include:</li>
            <ul style="list-style-type: none">
              <li>
                + (Unary Plus - represents a <i>positive</i> value, e.g. +a)
              </li>
              <li>
                - (Unary Minus - represents a <i>negative</i> value, e.g. -a)
              </li>
              <li>! (Greater than or equal to, e.g. a >= b)</li>
              <li>
                ++ (Increment Operator - increments the value of a variable by
                1, e.g. ++a OR a++)
              </li>
              <li>
                -- (Decrement Operator - decrements the value of a variable by
                1, e.g. --a OR a--)
              </li>
            </ul>
            <li>
              The last previous two operators (increment and decrement) are
              especially important because not only are they incredibly useful
              in multiple cases but they also have two variants of these
              operators:
            </li>
            <ol>
              <li>Pre-increment/decrement (also known as prefix)</li>
              <ul>
                <li>
                  Here our code <b>increments/decrements the value first</b>,
                  and <i>then</i>
                  performs the specified operation.
                </li>
                <pre><code style="margin-left: -125px" class="language-java">// Prefix increment example
public class PrefixExample {
    public static void main(String [] args) {
        int a = 5;
        System.out.println(++a);//this immediately increments to 5+1 and prints 6
        System.out.println(a);//this reflects the modifcation in the previous line AND also prints 6
    }
}</code></pre>
              </ul>
              <li>Post-increment/decrement (also known as postfix)</li>
              <ul>
                <li>
                  Here our code <b>performs the specified operation first</b>,
                  and <i>then</i> increments/decrements the value.
                </li>
                <pre><code style="margin-left: -125px">// Postfix increment example
public class PostfixExample {
    public static void main(String [] args) {
        int a = 5;
        System.out.println(a++);//prints the current value of a (5) BEFORE incrementing
        System.out.println(a);//value has been printed out, incremented, now prints 6
    }
}</code></pre>
                </ul>
              </ol>
            </ul>
          <br />
          <b>
            <li>Bitwise Operators</li>
          </b>
        </ol>
        <h1>TO REMEMBER:</h1>
        <br />
        <img src="https://qph.cf2.quoracdn.net/main-qimg-0755200da1dbafd34d3b0909ec3a2369.webp" alt="Precedence Table"
          class="center" />
      </article>
      <br />
      <hr />
    </section>
    <!-- WEEK 1 DAY 2-->
    <section class="main-section" id="Floating_Point">
      <br />
      <header><b>Floating-point Numbers</b></header>
      <article>
        <p>
          Floating-point numbers in Java are used to represent fractional values or numbers with a large range of
          possible values.
          They are primarily used when precise decimal calculations are not required.
          <br><br>
          Java uses two primitive data types to represent floating-point numbers: <b>float</b> and <b>double</b>.
        <ul>
          <li>The <b>float</b> data type is a 32-bit single-precision floating-point number</li>
          <li>The <b>double</b> data type (which we will use in this class rather than float) is a 64-bit
            double-precision floating-point number.
            This makes the double data type more accurate than the float data type.
          </li>
        </ul>
        </p>
        <p> We can create double variables and assign values to them using
          the same syntax we used for the other types:
          <br /><br />
          <pre><code class="language-java">double payRate = 42.5;</code></pre>
        </p>
        <p>The simplest way to convert a floating-point value to an integer 
          is to use a <b>type cast</b>, so called because it molds or “casts” 
          a value from one type to another.</p>
          <p>
            The syntax for type casting is to put the name of the type 
            in parentheses and use it as an operator.</p>
          <pre><code class="language-java">double payRate = 42.5;
int pay = (int) payRate;</code></pre>
          <p style="font-size: 50px;"><b>What is the value of the variable pay?</b></p>
        <header>Integer vs Floating Point Division</header>
        <p>In math, division often allows for remainders.
          It is why whenever a number is <b>NOT</b> evenly divisible by another number
          it can result in a decimal number opposed to a whole number
          e.g. 5/2 is equal to 2.5
          <br><br>
          However, <b>integer division</b> and division as we know from math class
          (also known as <b>floating-point division</b>) are two <b>different</b> ways of performing division
          operations.
          <br><br>
          <b>Integer division</b> is the division operation performed on two integers, resulting in an <b>integer
            quotient</b>.
          The result is obtained by discarding the fractional part of the division, if any.
          In other words, <b>it performs a "round towards zero" operation.</b>
        <ul>
          <li>For example, if you perform an integer division of 10 divided by 3, the result is 3 because it discards
            the fractional part.</li>
          <li>Similarly, if you divide -10 by 3 using integer division, the result is -3, as it still rounds towards
            zero.
          </li>
        </ul>
        On the other hand, <b>floating-point division</b> is the division operation performed on floating-point numbers
        (those with decimal places).
        <b>It produces a result with decimal places</b>, including the fractional part.
        This type of division is typically <b>more accurate and provides more precise results</b>.
        </p>
        <p>In Java, when dividing two integers using the '/' operator,
          <b>integer division is performed if both operands are integers</b>.
          <br><br>
          To perform floating-point division, <b>at least one of the operands should be a floating-point number</b>.
          <br><br>
          For example:
        </p>
        <pre><code class="language-java">int result = 10 / 3;//Integer division, result is 3
double result = 10.0 / 3;//Regular division, result is approximately 3.3333</code></pre>
        
        <p>It is important to be aware of the distinction between integer division and floating-point division,
          especially when working with different data types and when precision is required in calculations.</p>
      </article>
      <br />
      <hr />
    </section>
    <section class="main-section" id="Math_Methods">
      <br />
      <header><b>Math Methods</b></header>
      <article>
        <p>
          Java has a lot of built-in Math methods that allow us to perform more complex mathematical computations.
          The Math class is found in the java.lang package, so you don't have to import it.
          <br><br>
          For example, if you need to get the square root of a number, we use the Math.sqrt() method.
        </p>
        <p>Some frequently used Math class methods include:</p>
        <ul>
          <li><b>Math.abs</b>(n) - for computing the absolute value of a particular number</li>
          <li><b>Math.sqrt</b>(n) - for computing the square root of a particular number</li>
          <li><b>Math.pow</b>(base, exp) - for computing the result of a particular base raised to the power of a
            particular exponent</li>
        </ul>
        <p>You can learn more about the Java Math class methods from the Java API <a
            href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html">here</a></p>
      </article>
      <header>Generating Random Numbers</header>
      <article>
        <p>
          Most computer programs do the same thing every time they run, 
          meaning they are <b>deterministic</b>. Usually we want our
          programs to be deterministic since we expect the same 
          calculation to yield the same result. But for certain applications (e.g. games)
          we want to write programs that are <b>nondeterministic.</b>
          <br><br>
          It is hard for a computer to generate <i>truly</i> random numbers. But there are algorithms
          that generate unpredictable sequences called <b>pseudorandom</b> numbers. For
          most applications, <b>they are as good as random.</b>
        </p>
        <p>The <b>Math.random()</b> method returns a pseudorandom 
        double type number between 0.0 and 1.0, 
        where 0.0 is <b>inclusive</b> and 1.0 is <b>exclusive.</b></p>
        <p>When this method is first called, 
          it creates a single new pseudorandom-number generator</p>
          <pre><code class="language-java">public class RandomExample {
    public static void main(String [] args) {
        double rand = Math.random();//Generate random number
        System.out.println("Random Number:" + rand);//different each run
    }
}</code></pre>
        <p>to generate a random number in range:</p>
        <text style="margin: 10px; font-size: 35px">
          Math.random() * (max - min) + min;</text>
      </article>
      <br />
      <hr />
    </section>
    <section class="main-section" id="Error_Types">
      <br />
      <header><b>Types of Errors</b></header>
      <article>
        <p>
          There are three types of errors can occur in a program:
        <ol>
          <li>Compiler errors</li>
          <li>Run-time errors</li>
          <li>Logic errors</li>
        </ol>
        </p>
        <p><b>Compiler errors</b> occur when you <b>violate the syntax rules</b> of the Java language.
          For example, forgetting a semicolon at the end of a statement or
          that parentheses and braces have to come in matching pairs.
          So (1 + 2) is legal, but 8) is not.
          In the latter case, the program cannot be compiled, and the compiler displays an error.
        <ul>
          <li>Error messages from the compiler usually indicate where in the program the error occurred, and sometimes
            they can tell you exactly what the error is.</li>
        </ul>
        </p>
        <p><b>Run-time errors</b> occur while the interpreter is executing byte code
          and <b>something goes wrong</b>.
          These errors are also called “exceptions” because they usually
          indicate that something exceptional (and bad) has happened.
          (Example: attempting divide by zero)
        <ul>
          <li>When a run-time error occurs, the interpreter displays an
            error message that explains what happened and where.</li>
        </ul>
        </p>
        <p>The third type of error is the <b>logic error</b>.
          If your program has a logic error, it will compile and run
          without generating error messages, but <b>it will not do the right thing</b>.
          Instead, it will do exactly what you told it to do (even if it isn't the right solution).
        <ul>
          <li>Usually the compiler and the interpreter <b>CANNOT</b> help you,
            since they don't know what the right thing is. </li>
        </ul>
        </p>
      </article>
      <br />
      <hr />
    </section>
  <section class="main-section" id="System">
  <br />
  <header><b>The System class</b></header>
  <article>
    <p>
      So far we have used <b>System.out.println()</b> to display text to the
      screen. But what does it actually mean? <br /><br />
      <b>System</b> is a class (that belongs to the java.lang package,
       which is imported automatically) that provides methods related to the “system” or
      environment where programs run. 
    </p>
    <p>
      System.out represents the <b><i>Standard Output Stream</i></b
      >. That means that if we want to print any statement on the console, we
      should use the following statement: <br /><br />
      <text style="margin: 80px; font-size: 50px">System.out.print();</text>
    </p>
    <p>There are three methods we use to print statements:</p>
    <ol>
      <li><b>print(String s)</b></li>
      <ul>
        <li>Used to print on the console.</li>
        <li>Accepts a String as a parameter (we can concatenate parts to 
          the String if necessary, i.e. “Hello” + “ World”, etc. 
          however, it is typical convention to include all string literals 
          in the same pair of quotations if they are consecutive) </li>
        <li>After printing the statement, <b>the cursor remains on the same line.</b></li>
      </ul>
      <br>
      <li><b>println(String s)</b></li>
      <ul>
        <li>An upgraded version of the print() method, 
          also used to display text on the console.</li>
        <li>After printing the statement, 
          it throws <b>the cursor at the start of the next line.</b></li>
      </ul>
      <br>
      <li><b>printf(String format, datatype args)</b></li>
        <ul>
          <li>Accepts two parameters:</li>
            <ul>
              <li style="list-style-type: circle"><b>format</b>: It is a formatted String, uses placeholders 
                with specific conversion characters to refer to the 
                arguments that will be replaced when printing</li>
              <li style="list-style-type: circle">
                <b>args</b>: It is an argument referenced by the format specifiers. 
                If the number of arguments is more than the format specifiers, the other arguments are ignored. 
                The number of arguments may be zero.
              </li>
            </ul>
        </ul>
        <p>A formatted placeholder is declared as follows:</p>
        <text style="margin-left: -22px; font-size: 27px">%[flags][width][.precision]conversion-character</text>
        <p>With any flags, width, and precision as <b><i>optional</i></b> modifiers</p>
        <p>Feel free to consult the following: </p>
      <img style="width: 100%; height: 100%" 
      src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/printf%20ref.png?raw=true" alt="printf ref">
      <p>printf() throws: </p>
      <ul>
        <li>a <b>NullPointerException</b> if the format is null</li>
        <li>an <b>IllegalFormatException</b> if a format string contains illegal syntax</li>
        <li>an <b>IllegalFormatConversionException</b> if the placeholder and corresponding argument are not of the same type</li>
      </ul>
    </ol>
  </article>
  <header>Escape Sequences</header>
  <article>
    <p>The <b>\n</b> is an <b>escape sequence</b>, which is a sequence of characters that represents a special character. The backslash allows you to “escape” the string's
      literal interpretation.</p>
    <img style="width: 60%; height: 60%; display: block; margin-left: auto;
    margin-right: auto;" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/escape%20sequences.png?raw=true" alt="escape sequences">
  </article>
  <br />
  <hr />
</section>
<!-- WEEK 2 NOTES -->
<!-- WEEK 2 DAY 1-->

<section class="main-section" id="Datatypes">
  <br />
  <header><b>Data Types</b></header>
  <article>
    <p>As we previously discussed, a variable in Java must be declared as a specific 
      <b>data type</b>. These data types are divided into <b>two</b> groups:</p>
      <ul>
        <li><b>Primitive Data Types</b>, which specify the <b>size and type of variable values</b> and has <b>no additional methods</b></li>
        </ul>
        <p style="font-size: 30px; margin-left: 220px">AND</p>
        <ul>
        <li><b>Non-primitive data types</b>, also called reference types because they refer to <b>objects</b></li>
      </ul>
      
    <h2 style="font-size: 40px">Primitive Data Types</h2>
    <table>
      <tr>
        <th>Data Type</th>
        <th>Size</th>
        <th>Description</th>
      </tr>
      <tr>
        <td style="color: blue">byte</td>
        <td>1 byte</td>
        <td>Stores whole numbers from <b>-128</b> to <b>127</b></td>    
      </tr>
      <tr>
        <td style="color: blue">short</td>
        <td>2 bytes</td>
        <td>Stores whole numbers from <b>-32,768</b> to <b>32,767</b></td>
      </tr>
      <tr>
        <td style="color: blue"><b>int</b></td>
        <td>4 bytes</td>
        <td>Stores whole numbers from <b>-2,147,483,648</b> to <b>2,147,483,647</b></td>
      </tr>
      <tr>
        <td style="color: blue">long</td>
        <td>8 bytes</td>
        <td>Stores whole numbers from <b>-9,223,372,036,854,775,808</b> to <b>9,223,372,036,854,775,807</b></td>
      </tr>
       <tr>
        <td style="color: blue"><b>char</b></td>
        <td>2 bytes</td>
        <td>Stores a <b>single character/letter</b> or <b>ASCII values</b></td>
      </tr>
      <tr>
        <td style="color: blue">float</td>
        <td>4 bytes</td>
        <td>Stores fractional numbers. Sufficient for storing <b>6</b> to <b>7</b> decimal digits</td>
      </tr>
      <tr>
        <td style="color: blue"><b>double</b></td>
        <td>8 bytes</td>
        <td>Stores fractional numbers. Sufficient for storing <b>15</b> decimal digits</td>
      </tr>
      <tr>
        <td style="color: blue"><b>boolean</b></td>
        <td>1 bit</td>
        <td>Stores <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text> values</td>
      </tr>
    </table>

    <p>The main difference between primitive and non-primitive data types are:</p>
    <ul>
      <li>Primitive types are <b>predefined</b> (already defined) in Java. 
        Non-primitive types are created by the programmer and is not 
        defined by Java (except for <b>String</b>)</li>
        <br>
      <li>Non-primitive types can be used to call methods to 
        perform certain operations, while primitive types cannot.</li>
        <br>
      <li>A primitive type has always a value, 
        while non-primitive types can be null.</li>
        <br>
      <li>A primitive type <b>starts with a lowercase letter</b>, 
        while non-primitive types starts with an uppercase letter. (e.g. Strings, etc.) </li>
    </ul>
  </article>
  <br>
  <header>Strings (part 1)</header>
  <article>
  <p>We will revisit the concept of Strings in depth a bit later but for now just know that 
    <b>Strings</b> contain a sequence of “characters” strung together.</p>
  <p> Characters can be letters, numbers, punctuation marks, 
    symbols, spaces, tabs, etc.</p>
    <p>We can initialize a String simply by stating: </p>
    <pre><code class="language-java">String s = "Hello";</code></pre>
    <p>In most cases, we can use a String as a variable data type just like we have for int, double, etc. 
      (Although all Strings we create are technically <i>objects</i> and have more behaviors than the primitive data types --
    but we'll talk more about that later) </p>
    </article>
    <br>
  <header>Operators for Strings</header>
  <article>
  <p>In general, you cannot perform mathematical operations on strings, even if
    the strings look like numbers. The following expressions are illegal:</p>
    <ul>
      <li>"Hello" - 1</li>
      <li>"World" / 123</li>
      <li>"Hello" * "World"</li>
    </ul>
   <p>However, the <b>+</b> operator DOES work with strings. <br><br> For
    strings, the + operator performs <b>concatenation</b>, which means joining end-to-end. </p>
      <p>So "Hello, " + "World!" yields the string "Hello, World!".</p>
    <p>Or if you have a variable called name that has type String, the expression
      "Hello, " + name <b>appends the value of name to the hello string</b>, which creates
      a personalized greeting</p>
      <p>Since addition is defined for both numbers and strings, 
        Java performs automatic conversions you may not expect:</p>
      
        <p>What do we expect the following code to print?</p>
        <pre><code class="language-java">String s = "Hello";
System.out.println(1 + 2 + s);</code></pre>
      
      <p>How about this one?</p>
      <pre><code class="language-java">System.out.println(s + 1 + 2);</code></pre>
      <p>Java executes these operations <b>from left to right</b>.</p>
      <ul>
        <li>In the first example, 1 + 2 is
          3, and 3 + the value of variable s ("Hello") is <b>"3Hello"</b></li>
          <br>
        <li>In the second example, "Hello" + 1 is
          "Hello1", and "Hello1" + 2 is <b>"Hello12"</b></li>
      </ul>
  </article>
  <br />
  <hr />
</section>








<section class="main-section" id="Input">
  <br />
  <header><b>The Scanner Class</b></header>
  <article>
    <p>
      The System class also provides the special value <b>System.in</b>, which
      is an InputStream that provides methods for reading input from the
      keyboard. These methods are not easy to use; fortunately, Java provides
      other classes that make it easier to handle common input tasks.
    </p>
    <p>
      All reading done in Java uses the <b>Scanner</b> class. Using this class,
      we can create an object to read input from the standard input channel
      System.in (in our case, the keyboard)
    </p>
    <p>
      To use the Scanner class, it is necessary to <b>import the class Scanner from
      the library java.util</b> by including the following line at the top (before the class declaration) of
      program: 
    </p>
    <pre><code class="language-java">import java.util.Scanner;</code></pre>
    <p>We can declare a Scanner object by saying:</p>
    <pre><code class="language-java">Scanner sc = new Scanner (System.in);</code></pre>
    <ul>
      <li>
        sc is the <b>name of the Scanner object</b> (this can be changed and is
        entirely up to the person who writes the code)
      </li>
      <li>
        and System.in connects our object to <b>standard input</b> (the keyboard)
      </li>
    </ul>
    <p>
      The Scanner class has multiple built-in methods that we can access to help
      us read data, for example: we can use <b>sc.nextLine()</b> to read in a line of
      String(s) (spaces included)
    </p>
    <p>Other methods include:</p>
    <ul>
      <li><b>nextBoolean()</b>: reads a boolean value from the user</li>
      <li><b>nextByte()</b>: reads a byte value from the user</li>
      <li><b>nextDouble()</b>: reads a double value from the user</li>
      <li><b>nextFloat()</b>: reads a float value from the user</li>
      <li><b>nextInt()</b>: reads a int value from the user</li>
      <li>
        <b>next()</b>: reads a complete token (String) from the user. A complete token
        is preceded and followed by input that matches the delimiter pattern, in
        most instances this is a space
      </li>
    </ul>
    <p>When we are done reading in data, it is customary to <b>CLOSE</b> the Scanner to avoid 
      a possible memory leak. This is simple, we would just state thr following:
    </p>
    <pre><code class="language-java">sc.close();</code></pre>
    <p>Once we no longer need the Scanner (this is typically found at the last could lines of the method)</p>
  </article>
  <br>
  <header>The Scanner Bug</header>
  <article>
    <p>Now that we have had some experience with Scanner, we need to talk about some unexpected
      behavior that may occur</p>
      <p>When you read a String followed by an int, everything works just fine.But
        when you read an int followed by a String, something strange happens.</p>
      <pre><code class="language-java">System.out.print("What is your age? ");
age = in.nextInt();
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);</code></pre>

        <p>Try running this example code. It doesn't let you input your name, and it
          immediately displays the output:</p>
         <p>What is your name? Hello , age 45</p> 
          <p>When you call nextInt(), it reads characters until it gets to a non-digit.
            At this point, nextInt() returns 45. The program then displays the prompt
            "What is your name? " and calls nextLine(), which reads characters until it
            gets to a newline. <b>But since the next character is already a newline, nextLine
            returns the empty string "".</b>
          </p>
      <p>To solve this problem, you need an extra nextLine() after nextInt()</p>
      <pre><code class="language-java">System.out.print("What is your age? ");
age = in.nextInt();
in.nextLine();// read the newline
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);</code></pre>
      <p>This technique is common when reading int or double values that appear on
        their own line. <br><br><b>First you read the number, and then you read the rest of the
        line, which is just a newline character.</b></p>

</article>
<br>
  <header>Example: Inches to Centimeters</header>
  <article>
  <p>Now let's see an example, We will use a <b>Scanner</b> to input a measurement
    in inches, convert to centimeters, and then display the results.</p>

    <p>First let's declare the variables and create the Scanner object that we will call <b>input</b></p>
    <pre><code class="language-java">int inches;
double cm;
Scanner input = new Scanner(System.in);</code></pre>

  <p>Next, let's <b>prompt</b> the user for the input (prompts are important because they let the user know HOW they should interact with the program)</p>

  <p>We'll use print() instead of println() so they can enter the input on the <b>same line as the prompt</b>
    and use the Scanner method nextInt(), which reads input from the keyboard
    and <b>converts it to an integer</b></p>
    <pre><code class="language-java">System.out.print("Enter # of inches: ");
inches = input.nextInt();</code></pre>

  <p>Now we can multiply the number of inches entered by <b>2.54</b> (the number of centimeters there are per inch)
    and display the results</p>
    <pre><code class="language-java">cm = inches * 2.54;
System.out.print(inches + " inches = ");
System.out.printf("%.2f cm%n", cm);</code></pre>

  <p>This code works but it does have a minor flaw. If another programmer
    reads this code, they might wonder where 2.54 comes from.</p>

  <p><b>How can we modify this for clarity?</b></p>
  </article>
  <br />
  <hr>
</section>



<section class="main-section" id="Constants">
  <br />
  <header><b>Literals and Constants</b></header>
  <article>
    <p>A value that appears in a program, like 2.54 (or " inches = "), is called a <b>literal</b>.
      <br><br>
      In general, there is nothing wrong with literals. 
      <br><br>
      But when numbers like 2.54 appear in an expression with no explanation, they make code hard to read.
      And if the same value appears many times, and might have to change in the
      future, it <b>makes code hard to maintain</b>.
    </p>
    <p>For the benefit of others (and yourself in the future), it would be better to assign this value to
      a variable with a meaningful name:</p>
      <pre><code class="language-java">double cmPerInch = 2.54;
cm = inches * cmPerInch;</code></pre>
    <p>This version is easier to read and less error-prone, but it still has a problem.
      <b>Variables can vary</b>, but the number of centimeters in an inch does not.</p>
    <p>Once we assign a value to cmPerInch, it should never change.</p>
    <p>Luckily, Java provides a language feature that enforces that rule, the keyword <b>final</b>.</p>
    <pre><code class="language-java">final double CM_PER_INCH = 2.54;</code></pre>
    <p>Declaring a variable as <b>final</b> means that it cannot be reassigned once
      it has been initialized. If you try, <b>the compiler reports an error</b>. </p>
    <p>Variables declared as final are called <b>constants</b>.</p>
    <ul>
      <li>By convention, names for constants are <b>all uppercase</b>, with the underscore character (_) between words.</li>
    </ul>
  </article>
  <br />
  <hr>
  </section>




  <section class="main-section" id="Program">
    <br />
    <header><b>Putting it all Together</b></header>
    <article>
      <p>At this point, we have now seen enough Java to write useful programs that solve
        everyday problems. 
      </p>
      <p>We can: </p>
      <ol>
        <li>import Java library classes</li>
        <li>create a Scanner</li>
        <li>get input from the keyboard</li>
        <li>complete any necessary calculations</li>
        <li>print and format output to the screen</li>
      </ol>
        
      
    </article>
    <br />
    <hr>
    </section>




<!--Week 2 Day 2-->
<section class="main-section" id="Program_Structure">
  <br />
  <header><b>Program Structure</b></header>
  <article>
    <p>At this point, we have seen all of the elements that make up Java programs.
      <br><br>
      Figure 3.2 shows these organizational units.</p>
      <img style="
      width: 80%;
      height: 80%;
      display: block;
      margin-left: auto;
      margin-right: auto;
    "src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/programStructure.png?raw=true" alt="Figure 3.2">
  
  <table class="structure">
    <tr>
      <th>Element</th>
      <th>Definition</th>
    </tr>
    <tr>
      <td style="color: blue"><b>Package</b></td>
      <td>A collection of <i>classes</i>, which define <i>methods</i>.</td>
   
    </tr>
    <tr>
      <td style="color: blue"><b>Class</b></td>
      <td>In object-oriented programming, a class is a <b>basic building block</b>. 
        It can be defined as template that describes the data and behaviour 
        associated with the class instantiation.</td>
  
    </tr>
    <tr>
      <td style="color: blue"><b>Method</b></td>
      <td>A method in Java is <b>a block of code that, when called, 
        performs specific actions mentioned in it</b>. When you execute a class with the 
        Java interpreter, the runtime system <b>starts by calling the class's main() method</b>. 
        If there are other methods involved, the main() method then calls all 
        the other methods required to run your application. 
        <b>The main() method is the key to making a Java program executable.</b></td>
     
    </tr>
    <tr>
      <td style="color: blue"><b>Statement</b></td>
      <td>A statement is roughly equivalent to sentences in natural languages. 
        A statement forms a <b>complete unit of execution and almost always ends in a semicolon (;)</b></td>
      
    </tr>
     <tr>
      <td style="color: blue"><b>Expression</b></td>
      <td>An expression is a construct <b>made up of variables, operators, and method invocations</b>, 
        which are constructed according to the syntax of the language, that <b>evaluates to a single value</b></td>

    </tr>
    <tr>
      <td style="color: blue"><b>Token</b></td>
      <td>Tokens are the <b>basic building blocks</b> of a program. 
        They are the <b>smallest individual units of a program 
        that have meaning to the compiler</b> and are used to represent the various elements 
        of a program, such as <b>keywords, identifiers, operators, and literals</b></td>
     
    </tr>
  </table>
  <br>
  <img style="
  width: 98%;
  height: 98%;
  display: block;
  margin-left: auto;
  margin-right: auto;
"src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Program%20Outline.png?raw=true" alt="program outline">



  </article>

  <br />
  <hr />
</section>






<section class="main-section" id="Files">
  <br />
  <header><b>Reading from a File</b></header>
  <article>
    <p>
      As previously mentioned, we use a Scanner to read data whether or not the data is from the keyboard or a file. 
      <b>To read from a file we only need to make one or two modifications from what we learned from reading from the keyboard.</b>
    </p>
    <p>
      First, since we are using files we need to allow our program(s) to use them by including:
    </p>
    <pre><code class="language-java">import java.io.File;//import the File class</code></pre>
    <p>Since we are dealing with files, we HAVE to add a <b>throws Exception</b> declaration to main:</p> 
    <pre><code class="language-java">public static void main (String [] args) throws Exception {</code></pre> 
      <p>and create the File object that we will be reading from:</p>
    <pre><code class="language-java">File file = new File("[filename].txt");</code></pre>
    <p>And create a Scanner like we have previously done, only changing our reference from the keyboard to the corresponding file object:</p>
    <pre><code class="language-java">Scanner sc = new Scanner(file);</code></pre>
    <ul>
      <li>
        It is important that you remember to create the .txt file that you are trying to 
        reading from and make sure that it is in the correct directory or to specify the path 
        where the file is located when creating the File object else you will receive a <b>FileNotFoundException</b> 
        when you attempt to run your code.
      </li>
    </ul>
  </article>
  <br />
  <header>Writing to a File</header>
  <article>
    <p>
      We already know about writing data to the screen by using System.out, 
      but how about writing data to an outside source such as a file?
    </p>
    <p>
      Writing to a file is slightly less work since we do not have 
      to manually create the .txt file ourselves prior to running the program, 
      the program will do the creation for us. There are many different ways to 
      write to file in Java but in this class we will keep it relatively 
      simple and use the <b>PrintWriter</b> class.
    </p>
    <p>
      Like before, we need to import the PrintWriter class in order to use it:
    </p>
    <pre><code class="language-java">import java.io.PrintWriter;</code></pre>
    <p>Whether we are writing or reading, we are still dealing with files so we still HAVE to add a <b>throws Exception</b> declaration to main:</p> 
    <pre><code class="language-java">public static void main (String [] args) throws Exception {</code></pre> 
      <p>and create the File object that we will be reading from:</p>
    <p>We will use the PrintWriter class to create our file:</p>
    <pre><code class="language-java">PrintWriter pw = new PrintWriter("[filename].txt");</code></pre>
    <ul>
      <li>
        It is important to make sure that the filename that you are trying to create
       <b>does not already exist</b> in the directory that you are trying to create it in 
        otherwise, you will overwrite the file and lose your original file data 
      </li>
    </ul>
    <p>
      Now we can use the PrintWriter object to write, the same way that we wrote
      to the screen only replacing System.out with our PrintWriter object, 
      i.e. pw.print(), pw.println(), pw.printf(), etc.
    </p>
    <p>Just like with the Scanner, we need to <b>CLOSE</b> the PrintWriter object:
    </p>
    <pre><code class="language-java">pw.close();</code></pre>
    <p> The intepreter only knows that the program is finished writing
      to the file <b>after we close</b> the PrintWriter, so if we forget to close 
      the PrintWriter the file may appear empty.
    </p>
  </article>
  <br />
  <hr />
</section>

<!--WEEK 4-->
<!--Week 4 Day 1-->
<section class="main-section" id="Relational_Operators">
  <br />
  <header><b>Relational Operators</b></header>
  <article>
    <p>So far we have seen programs that do pretty much the same thing
      every time, regardless of the input. For more complex computations, 
      programs usually <b>react to the inputs, check for certain conditions, 
      and generate appropriate results.</b> </p>
      <p>We mentioned relational operators briefly before but let's discuss how 
        they work, more in depth:
      </p>
      <p><b>Relational operators</b> are used to <b>check conditions like whether two values
        are equal, or whether one is greater than the other.</b></p>
        <table class="relation">
          <tr>
            <td><b>x == y</b></td>
            <td style="color: green">// x is equal to y</td>
          </tr>
          <tr>
            <td><b>x != y</b></td>
            <td style="color: green">// x is not equal to y</td>
          </tr>
          <tr>
            <td><b>x > y</b></td>
            <td style="color: green">// x is greater than y</td>  
          </tr>
          <tr>
            <td><b>x < y</b></td>
            <td style="color: green">// x is less than y</td> 
          </tr>
           <tr>
            <td><b>x >= y</b></td>
            <td style="color: green">// x is greater than or equal to y</td> 
          </tr>
          <tr>
            <td><b>x <= y</b></td>
            <td style="color: green">// x is less than or equal to y</td>
          </tr>
        </table>
        <p>You have probably seen these operations before, but it is important to note that the Java
          operators are different from the mathematical symbols like =, &#8800;, and ≤.</p>
        <p> A common error is to use a single = instead of a double == </p>
        <p> Remember that:</p>
        <ul>
          <li> <b>=</b> is the <b>assignment</b> operator</li>
          <li> and <b>==</b> is a <b>comparison</b> operator</li>
        </ul>
        <p>The two sides of a relational operator must be <b>compatible</b></p>
        <p>For example, the expression: <b>5 < "6"</b> is <b>invalid because 5 is an int and "6" is a String</b></p>
        <p>However, when evaluating the expression <b>5 (an int) < 6.0 (a double)</b>, 
          Java <b>automatically converts the 5 to 5.0</b> because when comparing values of different 
          numeric types, Java applies the same conversion rules we saw previously with the assignment operator.</p>

        <p>The result of a relational operator is one of two special values, either <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text>.
          <br><br>
          These values belong to the data type <b>boolean</b>. In fact, they are the only
          boolean values.</p>
        
  </article>
  <br />
  <hr />
</section>
<section class="main-section" id="Logical_Operators">
  <br />
  <header><b>Logical Operators</b></header>
  <article>

    <div class="container" style="width: 100%; display: table;">


      <div style="display: table-row">
        <div style="width: 50%; display: table-cell;">
        <p>Java has three logical operators:</p>
       <ul style="list-style: none;">
          <li><b>&&</b></li>
          <li><b>||</b></li>
          <li>and <b>!</b></li>
        </ul> 
        </div>
    
        <div style="display: table-cell;">
           <p>Which respectively stand for:</p>
          <ul style="list-style: none;">
            <li><b>and</b></li>
            <li><b>or</b></li>
            <li>and <b>not</b></li>
          </ul>
        </div>
      </div>
    </div>

      <p>The results of these operators are similar to their meanings
        in English.</p>
        <p>For example:</p>
        <ul>
          <li><b>(x > 0 && x < 10)</b> is <text style="color: blue"><b>true</b></text> when <text style="font-size: 35px;">x is <b>both</b> greater than zero <b>and</b>
            less than 10</text></li>
          <li>The expression <b>(evenFlag || n % 3 == 0)</b> is <text style="color: blue"><b>true</b></text> if <text style="font-size: 35px;"><b>either</b> condition 
            is true, that is, if evenFlag is true <b>or</b> the number n is divisible by 3</text></li>
            <li>And the ! operator inverts a boolean expression, so <b>!evenFlag</b> is <text style="color: blue"><b>true</b></text> 
              <text style="font-size: 35px;">if evenFlag is <b>not true (false)</b></text>
              </li>
        </ul>

        <p>Logical operators evaluate the second expression only when necessary. For
          example:</p>
          <ul>
            <li><b>(<text style="color: blue">true</text> || anything)</b> is always <text style="color: blue"><b>true</b></text>, 
              so Java does not need to evaluate the expression <b>anything</b></li>
            <li>and <b>(<text style="color: blue">false</text> && anything)</b> is <b>always <text style="color: blue">false</text></b></li>
          </ul>
          <p>Ignoring the second operand, when possible, is called <b>short circuit evaluation</b>, by analogy with an electrical circuit.</p>

          <p>Short circuit evaluation can save time, especially if <b>anything</b> takes a long time to evaluate. 
            It can also avoid unnecessary errors, if <b>anything</b> might fail.</p>
  </article>
  <br />
  <header>De Morgan's Laws</header>
  <article>
    <p>If I told you I would show you a picture of a <b>blue square</b> and then you saw the picture and it <b>wasn't true</b>, which part of my claim “a blue square” wasn't true? <br><br>
      Maybe it was a square and it was a color other than blue? Or maybe it wasn't even a square at all? Maybe it was neither blue NOR a square entirely? <br><br>
      You could write this as a logic statement like below using negation (!) and the AND (&&) operator since <b>both parts have to be true for the whole statement to be true</b>.</p>
      <code><text>!(a && b)</text>
      <text style="color: lightskyblue; font-size:20px">//a = "blue"</text>
      <text style="color: lightskyblue; font-size:20px">//b = "square"</text></code>
    <p>If you ever have to negate an expression that contains logical operators, and you probably 
      will, <b>De Morgan's laws</b> can help.</p>
    <p>De Morgan's Laws were developed by Augustus De Morgan in the 1800s. 
      They show how to simplify the negation of a complex boolean expression, 
      which is when there are multiple expressions joined by an AND (&&) or OR (||), such as <br><b>(x < 3) && (y > 2)</b>. <br><br>
      Negating a logical expression is the same as negating each term and changing the operator. 
      The ! operator takes precedence over && and ||, so you don't have to put parentheses around the individual terms <b>!A</b> and <b>!B</b>.
     </p>
      <p>Here's an easy way to remember De Morgan's Laws:</p> 
      <ul>
        <li>move the NOT inside, AND becomes OR </li>
        <li>and move the NOT inside, OR becomes AND</li>
      </ul>
      <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/demorgan.png?raw=true" alt="De Morgan's Law"/>
     <p>In Java, De Morgan's Laws are written with the following operators:</p>
     <ul>
      <li><b>!(a && b)</b> is equivalent to <b>!a || !b</b></li>
      <li><b>!(a || b)</b> is equivalent to <b>!a && !b</b></li>
     </ul>
     <p>Going back to our example above, using De Morgan's Laws:</p> 
     <ul style="list-style: none">
      <li><b>!("blue" && "square")</b> is equivalent to <b>!("blue") or !("square")</b></li>
     </ul>
     <p>You can also simplify negated boolean expressions that have relational operators like <, >, ==. You can remove negation by moving it inside and flipping the relational operator to its opposite sign. 
      <br><br>For example, <b>(!) not (c equals d) is the same as saying c does not equal d</b>.</p>
      <p>An easy way to remember this is to:</p>
      <ul style="list-style: none">
        <li><b>Move the NOT inside, flip the sign</b></li>
        <li>i.e. <b>== becomes !=, < becomes >=, and > becomes <=</b></li>
      </ul> 
      <p>In this case, negating each term means using the “opposite” relational operator. For example:</p>
      <ul>
        <li><b>!(x < 5 && y == 3)</b> is the same as <b>x >= 5 || y != 3</b></li>
        <li><b>!(x >= 1 || y != 7)</b> is the same as <b>x < 1 && y == 7</b></li>
      </ul>
      <p>It may help to read these examples out loud in English. For instance, <b>"If I
        don't want the case where <text style="font-size: 35px">x is less than 5 and y is 3</text>, then I 
        need <text style="font-size: 35px">x to be greater than or equal to 5, or I need y to be anything but 3</text>."</b></p>
      <p>You should be able to show that two boolean expressions are equivalent. 
        One way to do this is by using <b>truth tables</b>.
        <br><br>For example, we can show that <b>!(a && b) == !a || !b</b> by constructing the truth table below 
        and seeing that they give identical results for the 2 expressions (the last 2 columns in the table below are identical!):</p>
        <table class="truth">
          <tr>
            <th>a</th>
            <th>b</th>
            <th>!(a && b)</th>
            <th>!a || !b</th>
          </tr>
          <tr>
            <td>true</td>
            <td>true</td>
            <td>false</td>
            <td>false</td>
          </tr>
          <tr>
            <td>false</td>
            <td>true</td>
            <td>true</td>
            <td>true</td>
          </tr>
          <tr>
            <td>true</td>
            <td>false</td>
            <td>true</td>
            <td>true</td>
          </tr>
          <tr>
            <td>false</td>
            <td>false</td>
            <td>true</td>
            <td>true</td>
          </tr>
        </table>  
        <p>Often, you can <b>simplify boolean expressions to create equivalent expressions</b>. <br><br>
          For example, applying De Morgan's Laws to <b>!(x < 3 && y > 2) yields !(x < 3) || !(y > 2)</b> as seen in the figure below. 
          <br><br>
          This can then be simplified further by <b>moving the not operator inside and flipping the relation operators</b>. 
          So, <b>!(x < 3) || !(y > 2) is simplified to (x >= 3 || y <= 2)</b> where the relational operators are flipped and the negation is removed. 
          These two simplification steps are seen below.</p>
        <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/demorganex.png?raw=true" alt="example"/>
  </article>
  <br />
  <hr />
</section>
<section class="main-section" id="Conditional_Statements">
  <br />
  <header><b>Conditional Statements</b></header>
  <article>
  <p>Our programs have so far been linear. In other words, the programs have executed from top to bottom without major surprises or conditional 
    behavior. <br><br> However, we usually want to add <b>conditional logic</b> to our programs. By this we mean functionality that's in one way or another 
    <b>dependent on the state of the program's variables</b>. <br><br>
    To branch the execution of a program based on user input, for example, we need to use something known as a <b>conditional statement</b>. </p>
  <header>The if Statement</header>
  <p>The simplest conditional statement in Java is the <b>if statement</b>:</p>
  <pre><code class="language-java">if (x > 0) {
    System.out.println("x is positive");
}</code></pre>
  <p>An if statement specifies a statement(s) to be executed <b>only if a particular boolean expression is true</b></p>
  <p>The expression in parentheses is called the <b>condition</b>.</p>
  <ul>
    <li>If it is <text style="color: blue;"><b>true</b></text>, the <b>statements in braces get executed</b>.</li>
    <li>If the condition is <text style="color: blue;"><b>false</b></text>, execution <b>skips over that block of code</b>.</li>
  </ul>
  <p>The condition in parentheses can be any boolean expression.</p>        
  </article>
  <br />
  <header>An if/else Block</header>
  <article>
   <p>A second form of conditional statement has two possibilities, indicated by <b>if</b> and <b>else</b>.</p>
   <p>The possibilities are called <b>branches</b>, and the condition determines which one gets executed:</p>
   <pre><code class="language-java">if (x > 0) {
    System.out.println("x is positive");
} else {
    System.out.println("x is NOT positive");
}</code></pre>
   <p>If the value of x is greated than zero, we know that x is positive, and this code fragment displays a message to that effect.</p>
   <p>If the condition is false, the second print statement is executed instead. Since the condition must be <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text>, 
    exactly one of the branches will run.</p>
    <p>The <b>braces are optional for branches that have only one statement</b>. So we could have written the previous example this way:</p>
    <pre><code class="language-java">if (x > 0)
    System.out.println("x is positive");
else 
    System.out.println("x is NOT positive");</code></pre>
  <p>However, it's better to use braces – even when they are optional – to avoid
    making the mistake of adding statements to an if or else block and forgetting
    to add the braces.</p>
    <pre><code class="language-java">if (x > 0)
    System.out.println("x is positive");
    System.out.println("x is NOT positive");</code></pre>
   <p>This code is misleading because it's not indented correctly. Since there are no braces, 
    only the first println is part of the if statement. Here is what the compiler actually sees:</p> 
   <pre><code class="language-java">if (x > 0) {
    System.out.println("x is positive");
}
System.out.println("x is NOT positive");</code></pre>
   <p>As a result, <b>the second println runs no matter what</b>. <br><br>Even experienced
    programmers make this mistake; check out 
    <a href="https://www.synopsys.com/blogs/software-security/understanding-apple-goto-fail-vulnerability-2.html">Apple's “goto fail” bug.</a></p>
  </article>
  <br />
  <header>Ternary Operator</header>
  <article>
   <p>There is also a short-hand if else, which is known as the <b>ternary operator</b> because it consists of three operands.</p>
   <p>It can be used to replace multiple lines of code with a single line, and is most often used to replace simple if/else statements:</p>
   <p>The syntax is as follows:</p>
   <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/ternary.png?raw=true" alt="ternary operator"/>
   <p>So we can modify our previous if/else block using the ternary operator as follows:</p>
   <pre><code class="language-java">String result = (x > 0) ? "x is positive" : "x is NOT positive";
System.out.println(result);</code></pre>
  </article>
  <br />
  <hr />
</section>
<section class="main-section" id="Chaining_and_Nesting">
  <br />
  <header><b>Chaining and Nesting</b></header>
  <article>
  <p>Sometimes you want to check related conditions and choose one of several
    actions. One way to do this is by <b>chaining</b> a series of if and else statements.</p>
    <br />
  </article>
    <header>The else if Statement</header>
    <article>
    <p>We can use the <b>else if</b> statement to specify a new condition if the first condition is false.</p>
    <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/else%20if%20block.png?raw=true" alt="else if"/>
    <p>These chains can be as long as you want, although they can be difficult to
      read if they get out of hand. <br><br>One way to make them easier to read is to use
      <b>standard indentation</b>, as demonstrated in these examples. <b>If you keep all the
      statements and braces lined up, you are less likely to make syntax errors</b>.</p>
    <p>We can modify out previous if/else block (either printing out "x is positive" or "x is NOT positive") to include more specific options:</p>
    <pre><code class="language-java">if (x > 0) {
    System.out.println("x is positive");
} else if (x < 0) {
    System.out.println("x is negative");
} else {
    System.out.println("x is zero");
}</code></pre>
    <p>Now we can further specify for values of x that are not positive, whether they be 0 or a negative number.</p>
  </article>
  <br />
    <header>Nested if Statements</header>
    <article>
    <p>In addition to chaining, you can also make complex decisions by <b>nesting</b> one
      conditional statement inside another. We could have written the previous
      example as:</p>
    <pre><code class="language-java">if (x > 0) {
    System.out.println("x is positive");
} else {
    if (x < 0) {
        System.out.println("x is negative");
    } else {
        System.out.println("x is zero");
    }
}</code></pre>
    <p>The <b>outer conditional has two branches</b>. <br><br><b>The first branch contains a print
      statement, and the second branch contains another conditional statement,
      which has two branches of its own</b>. <br><br>
      These two branches are also print statements, but they could have been conditional statements as well.</p>
    <p>These kinds of nested structures are common, but they get difficult to read
      very quickly. <b>Good indentation</b> is essential to make the structure (or intended
      structure) apparent to the reader.</p>
    </article>
  <br />
  <hr />
</section>
<section class="main-section" id="Flag_Variables">
  <br />
  <header><b>Flag Variables</b></header>
  <article>
  <p>To store a <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text> value, you need a <text style="color:blue"><b>boolean</b></text> variable. 
   <br><br>You can create one like this:</p>  
  <pre><code class="language-java">boolean flag;//variable declaration
flag = true;//assignment
boolean testResult = false;//both declaration and assignment</code></pre>
  <p> Since relational operators evaluate to a boolean value, you can store the result of a comparison in a variable:</p>
  <pre><code class="language-java">boolean positiveFlag =  (x > 0);//true if x is positive
boolean negativeFlag =  (x < 0);//true if x is negative
boolean zeroFlag =  (x == 0);//true if x is zero</code></pre>
  <p>The parentheses are unnecessary, but they make the code easier to read. 
    A variable defined in this way is called a <b>flag</b>, because it signals or “flags” the presence or absence of a condition.</p>
  <p>You can use flag variables as part of a conditional statement later:</p>
  <pre><code class="language-java">if (positiveFlag){
    System.out.println("x is positive");
}</code></pre>
  <p>Notice that you don't have to write if (evenFlag == <text style="color:blue"><b>true</b></text>). Since evenFlag
    is a <text style="color:blue"><b>boolean</b></text>, it's already a condition. Likewise, to check if a flag is <text style="color:blue"><b>false</b></text>:</p>
  <pre><code class="language-java">if (!positiveFlag){
    System.out.println("x is NOT positive");
}</code></pre>
  </article>
  <br />
  <hr />
</section>
<!--Week 4 Day 2-->
<section class="main-section" id="Validating_Input">
  <br />
  <header><b>Validating Input</b></header>
  <article>
  <p>In our previous examples, we prompt the user to enter an int (whole number) that we will evaluate using our if/else block.</p> 
  <p>We use <b>.nextInt()</b>, so the Scanner is <b>expecting to read data that is compatible with an int</b>. <br><br>If the user enters a whole number, the Scanner accepts it and 
    converts it to a int. <br><br><b>But if the user types anything else, i.e a floating-point number, the Scanner throws
    an InputMismatchException.</b></p> 
    <p>We can prevent this error by checking the input before parsing it. 
      <br><br>The Scanner class has <text style="color:blue"><b>boolean</b></text> methods that can validate whether the input is of a particular type, in our case we can use 
    <b>.hasNextInt()</b> which will return <text style="color:blue"><b>true</b></text> if the <b>next token in this Scanner's input can be interpreted as an int value</b> 
    and <text style="color:blue"><b>false</b></text> otherwise.</p>
      

  </article>
  <br />
  <hr />
</section>




<section class="main-section" id="Switch_Statements">
  <br />
  <header><b>Switch Statements</b></header>
  <article>
  <p>Instead of writing many if/else statements, we can use the switch statement. </p> 
    <p>Unlike if-then and if-then-else statements, the switch statement <b>can have a number of possible execution paths</b>. 
      <br><br>A switch <b>works with the byte, short, char, and int primitive data types</b>. It also works with enumerated types (special data type that enables for a variable to be a set of predefined constants), 
      the String class, and a few special classes that wrap certain primitive types: Character, Byte, Short, and Integer</p>
    </p> The switch statement selects one of many code blocks to be executed:</p>  
    <img style="width: 45%; height: 45%; display: block;
    margin-left: auto;
    margin-right: auto;" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/switchstatement.png?raw=true" alt="switch statement"/>
    <p>This is how it works:</p>
    <ul>
      <li>The <b>switch expression is evaluated once</b>.</li>
      <li>The <b>value of the expression</b> is <b>compared with the values of each case</b>.</li>
      <li>If there is a <b>match</b>, the <b>associated block of code is executed</b>.</li>
      <li>The <b>break</b> and <b>default</b> keywords are optional, but extremely useful. We'll talk about this in a bit.</li>
    </ul>
    <p>Let's try an example that <b>reads in a number and uses it to calculate the day of the week</b>:</p>

    <pre><code class="language-java">Scanner sc = new Scanner (System.in);
System.out.print("Enter a number (1-7): ");
int day = sc.nextInt();</code></pre>

    <p>Now, let's write some code that will represent the following:</p>
    <ol>
      <li>Monday</li>
      <li>Tuesday</li>
      <li>Wednesday</li>
      <li>Thursday</li>
      <li>Friday</li>
      <li>Saturday</li>
      <li>Sunday</li>
    </ol>

  </article>
  <br />
  <header>The break Keyword</header>
  <article>
  <p>When Java reaches a <b>break</b> keyword, it <b>breaks out of the switch block</b>.
    This will <b>stop the execution of more code and case testing inside the block</b>.
    When a match is found, and the job is done, it's time for a break. <b>There is no need for more testing</b>.</p>  
   <p>A break can save a lot of execution time because it "ignores" the execution of all the rest of the code in the switch block.</p>

  </article>
  <br />
  <header>The default Keyword</header>
  <article>
  <p>The <b>default</b> keyword specifies some code to run if there is <b>no case match</b>.</p>  
   <p>Note that if the default statement is <b>used as the last statement in a switch block, it does not need a break</b>.</p>
    <br>
   <p>How can we modify our <a href="/courses/CISC1115/classwork_code/MY11Lab1Modified.java">previous lab</a> to utilize switch statements instead of the if/else-if/else block we used previously?</p>
  </article>
  <br />
  <header>Combining Cases</header>
  <article>
  <p>If the same outcome applies to more than one case we can also <b>combine</b> cases.</p> 
    
    <img style="width: 80%; height: 80%; display: block;
    margin-left: auto;
    margin-right: auto;" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/combineswitch.png?raw=true" alt="switch statement"/>
   

  </article>
  <br />
  <hr />
</section>


<section class="main-section" id="char_Data_Type">
  <br />
  <header><b>The char Data Type</b></header>
  <article>
  <p>Now that we have learned a bit more about user input and choices, what about if the choices AREN'T numbers? What if they were letters? Or symbols?</p>
  <p>The <b>char</b> data type is used to <b>store a single character</b>. The character <b>must be surrounded by single quotes</b>, like 'A' or 'c'</p> 
  <p></p> 
  <pre><code class="language-java">char choice = 'B';</code></pre>
  <p>Alternatively, we can use ASCII values, you can use those to display certain characters:</p>
  <pre><code class="language-java">char first = 65; 
char second = 66; 
char third = 67;
System.out.println(first);
System.out.println(second);
System.out.println(third);</code></pre>
  <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/ASCII.png?raw=true" alt="ASCII Table" />


  </article>
  <br />
  <header>Reading in chars</header>
  <article>
  <p>Unfortunately the Scanner class does not have a specific method used to read in char values the same we we can ints (.nextInt()), doubles (.nextDouble()), etc.</p>  
   <p>However, since we CAN read in Strings and Strings are made up of character values, there is a way around this:</p>
   <pre><code class="language-java">char choice = sc.next().charAt(0);</code></pre>

   <p>The <b>.charAt()</b> method <b></b>returns the character at the specified index in a String</b> and the <b>index of the first character is 0</b> (we will talk more about the other characters when we talk more about Strings and their methods)</p>
   <p>Doing this is a loophole to read in char values from the keyboard.</p>
  </article>
  <br />
  <hr />
</section>

<!-- WEEK 5 NOTES -->
    <!-- WEEK 5 DAY 1-->
    <section class="main-section" id="Loops">
      <br />
      <header><b>Loops</b></header>
      <article>
      <p>Programs are often used to automate repetitive tasks. Running the same code multiple times is called <b>iteration</b>.
      <br><br>Java provides language features that make iteration easy: loops such as the <b>while</b> loop, 
      the <b>do while</b> loop, and the <b>for</b> loop.</p>
      <p>In programming, loops are important to learn and understand
         how to use to be able to create dynamic programs that can do a lot of different things.</p>
      <p>Loops are a programming element that repeat a portion of code a set number of times until the desired process is complete. 
        Repetitive tasks are common in programming, and loops are essential to save time and minimize errors.</p>
      <p>Think about HW 1 and part 1 of HW 2: we processed the required medical dosage for a set of patients.<br><br> 
        Each patient's dosage is calculated EXACTLY the same way:
        <ul>
          <li>First by reading in the patient's weight,</li>
          <li>Then by converting the weight 
            from pounds (lbs) to kilograms (kg),</li>
          <li>Lastly, we multiply the weight in kilograms by 30 since each kilogram of weight requires 
            a dosage of 30 milligrams (mg)</li>
        </ul> 
      <p>Instead of rewriting the block of code for each new patient, we can implement a loop!</p>
      <p>When programmers write code, loops allow them to shorten what could be hundreds of lines of code to just a few.</p>
      <p>This allows them to write the code once and repeat it as many times as needed, making it more likely for the program to run 
        as expected (less chance of error).</p>
      </article>
      <br />
      <header>The while Loop</header>
      <article>
        <p>A while loop is a control flow statement that allows code to be executed repeatedly based on a given <text style="color:blue"><b>boolean</b></text> condition.</p>
        <p>The while loop can be thought of as a <b>repeating if statement</b>.</p>
        <p>The expression in parentheses is called the <b>condition</b>. The statements in braces
          are called the <b>body</b>. The flow of execution for a while statement is:</p>
          <ol>
            <li>Evaluate the condition, yielding <text style="color:blue"><b>true</b></text> or <text style="color:blue"><b>false</b></text>.</li>
            <li>If the condition is <text style="color:blue"><b>false</b></text>, skip the body and go to the next statement.</li>
            <li>If the condition is <text style="color:blue"><b>true</b></text>, execute the body and go back to step 1.</li>
          </ol>
        <p>This type of flow is called a loop, <b>because the last step loops back around to
          the first</b>.</p>
        </article>
        <br />
      <header>The while Loop vs The if Statement</header>
      <article>
        <p>You may find that the breakdown of the while loop sounds quite similar to the parts that make up the if statement that we previous discussed.
          And you would be right! <br><br>There are similarities in the structure of both concepts, however, there are a significant differences as well.
        </p>
        <p>An <b>if statement</b>, when <text style="color:blue"><b>true</b></text>, will only <b>execute the inner block of code once</b>.</p>
        <p>In contrast, a <b>while loop</b> will continue to <b>execute the inner block of code as long as the condition is <text style="color:blue"><b>true</b></text></b>.</p>
        <p>If the condition is initially <text style="color:blue"><b>false</b></text> (in either case), the inner block of code will never execute.</p>
        <p><b>The body of the loop should change the value of one or more variables so that,
          eventually, the condition becomes false and the loop terminates.</b></p>
          <p>The termination is important, otherwise <b>the loop will repeat forever</b>, which is called an <b>infinite loop</b>. <br><br>An endless source
          of amusement for computer scientists is the observation that the directions on
          shampoo, “Lather, rinse, repeat,” are an infinite loop.
          </p>
        <p>For example, we can write a simple loop to act as a countdown:</p>
        <pre><code class="language-java">int n = 10;
while (n > 0) {
    System.out.println(n);
    n = n - 1;
}
System.out.println("Blastoff!");</code></pre>
        <p>You can almost read the while statement like English: <br><br><b>"While n is greater
          than zero, print the value of n and then reduce the value of n by 1. When you
          get to zero, print Blastoff!"</b></p>
        
          <p>In this case, the loop terminates when n is no longer positive. But in general, it is not so easy to tell whether a loop terminates.</p>
      </article>
      <br />
        <header>Collatz Conjecture</header>
        <article>
        <p>The Collatz conjecture is one of the most famous unsolved problems in mathematics, named after Lothar Collatz.   
          The conjecture asks whether repeating two simple arithmetic operations will eventually transform every positive integer into 1. </p>
        <p>The problem is stated as follows: </p>
        <ul>
          <li>Start with any positive integer n</li>
          <li>If n is even, the next number is n/2</li>
          <li>If n is odd, the next number is 3n+1</li>
        </ul>
        <p>The conjecture is that these sequences <b>always reach 1</b> (more specifically ends in the values 4, 2, 1), 
          <b>no matter which positive integer is chosen to start the sequence</b>.</p>
        <pre><code class="language-java">import java.util.Scanner;

public class CollatzConjecture {
    public static void main(String [] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Enter a posititve Integer: ");
        int x = sc.nextInt();
        System.out.println(x);
        while (x != 1) { //until x is equal to 1
            if (x % 2 == 0) { //x is even
                x = x / 2;
                System.out.println(x);
            } else { //x is odd
                x = 3 * x + 1;
                System.out.println(x);
            }
        }
    }          
}</code></pre>
<p>Each time through the loop, the program displays the value of x and then
  checks whether it is even or odd. <br><br>If it is even, the value of x is divided by two.
  <br><br>If it is odd, the value is replaced by 3x + 1. <br><br>For example, if the starting value
  (the argument passed to sequence) is 3, the resulting sequence is 3, 10, 5, 16,
  8, 4, 2, 1.</p>
<p>Since x sometimes increases and sometimes decreases, there is no <i>obvious</i> proof
  that x will ever reach 1 and that the program will ever terminate.</p>
<p>However, the rules of Collatz Conjecture lets us know that it will.</p>
<p>The hard question is whether this program terminates for all values of x. So
  far, no one has been able to prove it or disprove it! </p>
        </article>
        <br />
        <header>Generating Tables</header>
        <article>
          <p>Loops are good for generating and displaying tabular data.</p>
          <p>The following code starts with an integer n and then use a loop to display a multiplication table with a sequence of
            values (n*1, n*2, ... etc.) in the left column and the results in the right column (after the equal sign):</p>
          <p>Let's trace it!</p>
          <pre><code class="language-java">int n = 9; 
int i = 1;
while(i <= 10) {
    System.out.printf("%d * %d = %d \n", n, i, n * i);
    i++;
}</code></pre>
        </article>
        <br />
        <header>Counters</header>
        <article>
        <p>Sometimes, we know in advance how many times we want to do something, i.e.:</p>
        <ul>
          <li>do this ten times</li>
          <li>do this five times</li>
          <li>pick a random number, and do it that many times</li>
        </ul>
        <p>We can do that sort of thing with a while loop, but we have to use a <b>counter</b>.</p>
        <p>A counter variable in Java is a special type of variable which is used in the loop to <b>count the repetitions or to know about in which 
          repetition we are in.</b> <br><br>In simple words, a counter variable is a variable that <b>keeps track of the number of times a 
          specific piece of code is executed</b>.</p>
        <p>The counter variable is declared and used in the same way as the normal variables are declared and used.</p>
        <p>The counter variable can be of only integer type because it is very easy to increase the value of integer type variable.</p>
        <p>The counter variable is very easy to understand and use. The technique of using the counter variable in Java is as follows:</p>
        <p>Before the repeating cycle, we have to initialize it to zero.</p>
        <p>After that, we're going to be adding 1 to the counter everytime we repeat the loop. 
        And when the counter reaches a predetermined value, we'll stop looping.</p>
        <p>Let's take a simple example to understand the concept of the counter variable in Java: </p>
        <pre><code class="language-java">int count = 0;// count is initialized
while (count <= 10) {// count is tested
    System.out.print(count + " ");
    count++;// count is incremented, increased by 1
}</code></pre>
        <p>The first statement in the loop prints value of count. 
          <br><br>The second statement uses the increment operator to add one to number. <br><br>
          After it executes, the loop starts over. It tests the boolean expression again. <br><br>
          If it is true, the statements in the body of the loop are executed. 
          <br><br>This cycle repeats until the boolean expression number <= 10 is false.</p>

        <p>The loop in above example is controlled by a counter, so it is known as a <b>counter controlled loop</b>.</p>
        <p>However, while loops are best for repeating <b>as long as something is true</b>:</p>
        <ul>
          <li>keep going as long as they keep typing in a positive number</li>
          <li>keep going as long as they haven't typed in a zero</li>
        </ul>
          <p>The loop in next example is a <b>sentinel controlled loop</b>, <b>a special value (the "sentinel")</b> that is used to signify 
            <b>when the loop is done</b>.</p>

          <pre><code class="language-java">public static void main(String [] args) {
    int sum = 0;// initialize the sum
    int count = 0;//initialize counter
    //create a Scanner object for keyboard input.
    Scanner sc = new Scanner(System.in);
      
    //get the first value.
    System.out.print("Enter first integer (enter 0 to quit): ");
    int value = sc.nextInt();
      
    while (value != 0) {
        count++;//increment count for each value
        sum = sum + value;//add value to sum
      
        //get next value from the user to avoid infinite loop!
        System.out.print("Enter next integer (enter 0 to quit): ");
        value = sc.nextInt();
    }
      
    //display the total sum and count
    System.out.println("Sum of the integers: " + sum);
    System.out.println("Total integers entered: " + count);
}</code></pre>
      <p>Here the loop allows the user to keep entering numbers (and adding the entered numbers to the running sum and counting how many numbers are entered) 
        UNTIL the user enters a zero.</p>

        </article>
        <br />
        <header>Pretest vs Posttest Loops</header>
        <article>
        <p>Now that we know a bit about iteration, let's discuss the different types:</p>
        <p>A <b>pretest</b> loop <b>tests its condition before each iteration</b>.<br><br>Examples include:</p>
        <ul>
          <li>while loops</li>
          <li>for loops</li>
        </ul>
          
        <p>A <b>posttest</b> loop <b>tests its condition after each iteration</b>.<br>
          A posttest loop will <b>always execute at least once</b>.<br><br>Examples include:</p>
        <ul>
          <li>do/while loops</li>
        </ul>
        <p>This type of loop is useful when you need to run the body of the loop at least once.</p>
      </article>
        <br />
      <header>The do/while Loop</header>
      <article>
      <p>The do/while loop is a variant of the while loop.</p>
      <p>It is very similar to the while loop with one distinct difference. <br><br>
        So let's discuss the specific behavior that separates them from each other:</p>
        <ul style="list-style: none;">
          <li>As previously discussed, the <b>while loop checks the condition first</b>, and if it returns <text style="color:blue"><b>true</b></text>, the code within it runs. 
            The loop continues until the condition provided returns <text style="color:blue"><b>false</b></text>, then stops.</li>
            <img style="width: 90%; height: 90%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Java-while-loop.png?raw=true" alt="while flowchart"/>
            <br><br>
          <li>Alternatively, the <b>do/while loop runs its code once before checking the condition</b> and runs again <b>only</b> if the condition is <text style="color:blue"><b>true</b></text>. 
            This continues until the condition check returns <text style="color:blue"><b>false</b></text>, then it stops before the next loop starts.
          </li>
            <img style="width: 90%; height: 90%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/java-do-while.png?raw=true" alt="do-while flowchart"/>
        </ul>
        <p>The loop will <b>always be executed at least once</b>, even if the condition is false, 
          because the code block is executed <b>before the condition is tested</b>.</p>





          <p>The execution of do/while loop is as follows: </p>
          <ol>
            <li>Enter the do/while loop</li>
            <li>The statements inside the body of the loop get executed</li>
            <li>Any updation takes place</li>
            <li>The flow jumps to Condition</li>
            <li>The Condition is tested</li>
              <ol style="list-style: lower-alpha;">
                <li>If Condition yields <text style="color:blue"><b>true</b></text>, go to Step 6</li>
                <li>If Condition yields <text style="color:blue"><b>false</b></text>, the flow goes outside the loop</li>
              </ol>
            <li>The flow goes back to Step 2</li>
          </ol>



          <p>As aforementioned, the do/while loop is useful for when you want to execute something at least once.</p>

          <p>As for a good example for using do/while vs. while, lets say we want to modify our previous Medical Dosage Calculator.</p>

          <p>We could approach this by using a while loop and checking after each calculation if the person wants to exit the program (as we discussed last class) </p>

          <pre><code class="language-java" style="font-size: 23.3px;">public static void main(String [] args) {
    final double LBS_TO_KG = 0.45359237;
    final double DOSE_PER_KG = 30;
    Scanner sc = new Scanner(System.in);
    //create count to keep track of # of patients
    int count = 0;
    //prompt user to interact
    System.out.print("Would you like to enter a patient? (Y/N):");
    //identify new patient Y/N?
    char op = sc.next().charAt(0);//reads in Y or N
    
    while (op != 'N' && op != 'n') {
        System.out.print("Enter patient's weight: ");
        double weight = sc.nextDouble();
        double kilo = weight * LBS_TO_KG;
        double dosage = kilo * DOSE_PER_KG;
        count++;
        System.out.printf("Dosage required for Patient %d is: %.2f%n%n", 
                            count, dosage);
        //prompt user to interact
        System.out.print("Would you like to enter another patient? (Y/N): ");
        //identify new patient Y/N?
        op = sc.next().charAt(0);//reads in Y or N
    }
    
    System.out.printf("%nTotal number of patients processed: %d%n", count);
    
}</code></pre>

          <p>Now we can probably assume that once the program is opened the user wants to 
            <b>interact with it at least once</b> so we could modify our code to use a do/while loop.</p>
      </article>
     

      <br />
        <header>Keyword: break</header>
        <article>
        <p>We have already seen the <b>break statement</b> used earlier, it was used to "jump out" of a switch statement.
          <br><br>The break statement can also be used to <b>jump out of a loop</b>.</p>
          
          <p>The following example <b>stops the loop when i is equal to 4</b> despite the original condition of the while loop:</p>
          <pre><code class="language-java">int i = 0;
while (i < 10) {
    System.out.println(i);
    i++;
    if (i == 4) {
        break;
    }  
}</code></pre>
      </article>


      <br />
        <header>Keyword: continue</header>
        <article>
        <p>The <b>continue</b> statement breaks one iteration (in the loop), if a specified condition occurs, 
          and continues with the next iteration in the loop</p>
          
          <p>The following example <b>skips the value of 4</b>:</p>
          <pre><code class="language-java">int i = 0;
while (i < 10) {
    if (i == 4) {
        i++;//why do we need to do this? 
        continue;
    }
    System.out.println(i);
    i++; 
}</code></pre>
      </article>

      <br />
        <header>Putting it all Together</header>
        <article>
        <p>For example, we can use a do-while loop to keep reading input
          until it's valid:</p>

          <pre><code class="language-java">Scanner in = new Scanner(System.in);
boolean okay;
do {
    System.out.print("Enter a number: ");
    if (in.hasNextDouble()) {
        okay = true;
    } else {
        okay = false;
        String word = in.next();
        System.out.println(word + " is not a number");
    }
} while (!okay);
double x = in.nextDouble();
System.out.println("\nYou entered the number: " + x);</code></pre>

  <p>Although this code looks complicated, it is essentially only three steps:</p>
  <ol>
    <li>Display a prompt</li>
    <li>Check the input; if invalid, display an error and start over</li>
    <li>Read the input</li>
  </ol>
  <p>The code uses a <b>flag variable, okay</b>, to indicate whether we need to repeat the
    loop body. <br><br>If <b>.hasNextDouble()</b> returns <text style="color:blue"><b>false</b></text>, we consume the invalid input
    by calling <b>.next()</b>. We then display an error message. <br><br>The
    loop terminates when <b>.hasNextDouble()</b> returns <text style="color:blue"><b>true</b></text>.</p>

    <p>A simpler way to solve this problem is to use a <b>break statement</b>.</p>

    <pre><code class="language-java">Scanner in = new Scanner(System.in);
while (true) {
    System.out.print("Enter a number: ");
    if (in.hasNextDouble()) {
        break;
    } else {
        String word = in.next();
        System.out.println(word + " is not a number");
    }
}
double x = in.nextDouble();
System.out.println("\nYou entered the number: " + x);</code></pre>

    <p>Using <text style="color:blue"><b>true</b></text> as a conditional in a while loop is an idiom that means <b>"loop
      forever"</b>, or in this case <b>"loop until you get to a break statement"</b>.</p>

    <p>Although break and continue statements give you more control of the loop
      execution, they can make code difficult to understand and debug. <br><br><b>Use them
      sparingly</b>.</p>

      </article>
      <br />
      <header>The for Loop</header>
      <article>
      <p>The loops we have written so far have several elements in common. <br><br>They
        start by:
        <ul>
          <li>initializing a variable</li>
          <li>they have a condition that depends on that
        variable</li>
        <li>and inside the loop they do something to update that variable</li>
        </ul>This
        type of loop is so common that there is another statement, the <b>for loop</b>, that
        expresses it more concisely.
        </p>
      <p>When we know exactly <b>how many times we want to loop through a block of code</b>, we use the for loop instead of a while loop.</p>
      <p>Unlike the while and do/while loops, the for loop has all three components enclosed in the parentheses, separated by semicolons: the
        <b>initializer</b>, the <b>condition</b>, and the <b>update</b>.
        </p>
      <ol>
        <li>The initializer runs once at the very beginning of the loop</li>
        <li>The condition is checked each time through the loop</li>
          <ul>
            <li>If it is <text style="color:blue"><b>false</b></text>, the loop ends</li>
            <li>Otherwise, the body of the loop is executed (again)</li>
          </ul>
        <li>At the end of each iteration, the update runs, and we go back to step 2</li>
      </ol>
      <p>The for loop is often easier to read because it puts all the loop-related statements at the top of the loop.</p>

      <p><b>How does the for loop work?</b></p>
      <ol>
        <li>Control falls into the for loop, initialization is done</li>
        <li>The flow jumps to the Condition</li>
        <li>Condition is tested</li>
        <ul>
          <li>If the Condition is <text style="color:blue"><b>true</b></text>, the flow goes into the body of the loop</li>
          <li>If the Condition is <text style="color:blue"><b>false</b></text>, the flow goes outside the loop</li>
        </ul>
        <li>(If <text style="color:blue"><b>true</b></text>) The statements inside the body of the loop get executed.</li>
        <li>The flow goes to the Updation</li>
        <li>Updation (the variable is updated) takes place and the flow goes to Step 3 again</li>
        <li>(If <text style="color:blue"><b>false</b></text>) The for loop has ended and the flow has gone outside of the loop</li>
      </ol>
      <img style="width: 90%; height: 90%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Java-For-loop-with-Examples.png?raw=true" alt="for loop flowchart"/>

      <p>The example below will print the numbers 0 to 4 (inclusive):</p>
      <pre><code class="language-java">for (int i = 0; i < 5; i++) {
    System.out.println(i);
}</code></pre>
    <ul>
      <li>The first statement in the parentheses, initializes a variable before the loop starts <b>(int i = 0)</b></li>
      <li>The second defines the condition for the loop to run <b>(i must be less than 5)</b></li>
      <ul>
        <li>If the condition is <text style="color:blue"><b>true</b></text>, the loop will start over again</li>
        <li>If it is <text style="color:blue"><b>false</b></text>, the loop will end</li>
      </ul> 
      <li>The last part enclosed in the parentheses increases a value <b>(i++)</b> each time the code block in the loop has been executed</li>
    </ul>

    <p>There is one difference between for loops and while loops: <b>if you declare a
      variable in the initializer, it only exists inside the scope of the for loop</b>.</p>

    <p>For example, if we attempted to print out the value of i after the loop we would get an error:</p>

    <pre><code class="language-java">for (int i = 0; i < 5; i++) {
    System.out.println(i);
}
System.out.println(i); // compiler error</code></pre>

    <p>The last line tries to display i (for no reason other than demonstration) but
      it won't work. <b>If you need to use a loop variable outside the loop, you have to
      declare it outside the loop</b>, like this:
      </p>

      <pre><code class="language-java">int i;
for (i = 0; i < 5; i++) {
    System.out.println(i);
}
System.out.println(i);</code></pre>

      <p>Assignments like i = i + 1 don't often appear in for loops, because Java
        provides a more concise way to add and subtract by one.</p>

      <p> Specifically, ++ is
        the increment operator; it has the same effect as i = i + 1.</p>

      <p>And -- is the
        decrement operator; it has the same effect as i = i - 1.
        </p>

      <p>If you want to increment or decrement a variable by an amount other than 1,
        you can use += and -=. For example, i += 2 increments i by 2.</p>

    <p>This example will only print <b>even values</b> between 0 and 10 (inclusive):</p>
    <pre><code class="language-java">for (int i = 0; i <= 10; i += 2) {
    System.out.println(i);
}</code></pre>
    <p>How can we rewrite this so that it iterates over every number (not just the even ones) 
      but only prints out the even numbers (that way the output will be the same as the previous code)? (Hint: use an if statement)</p>






    </article>
    <br />
        <header>Nested Loops</header>
        <article>
          <p>If a loop exists inside the body of another loop, it's called a <b>nested loop</b>. Here's an example of the nested for loop:</p>
          <pre><code class="language-java" style="font-size: 25px;">for (int i = 1; i <= 2; i++) {// Outer loop
    System.out.println("Outer: " + i);// Executes 2 times
    
    for (int j = 1; j <= 3; j++) {// Inner loop
        System.out.println(" Inner: " + j);// Executes 6 times (2 * 3)
    }
}</code></pre>
        <p>The inner loop will be re-executed for each iteration of the outer loop.</p>

        <p>Example: We can use the nested loop to iterate through each day of a week for 4 weeks (a month).
          <br><br>
          In this case, we can create a loop to iterate four times (4 weeks). 
          And, inside the loop, we can create another loop to iterate 7 times (7 days).</p>

        <pre><code class="language-java">public static void main(String [] args) {
    int weeks = 4;//4 weeks in a month (on average)
    int days = 7;// 7 days in a week
      
    // outer loop prints weeks
    for (int i = 1; i <= weeks; i++) {
        System.out.println("Week: " + i);
      
        // inner loop prints days
        for (int j = 1; j <= days; j++) {
            System.out.println("  Day: " + j);
        }
        System.out.println();//skip a line for every new week
    }
}</code></pre>

  <p>Alternate: for loop inside the while loop</p>
  <p>We can write the same exact program only using a while loop as the outer loop instead. The following code shows how:</p>

  <pre><code class="language-java">int weeks = 4;
int days = 7;
int i = 1;//necessary for outer loop

// outer loop prints weeks
while (i <= weeks) {
    System.out.println("Week: " + i);

    // inner loop
    for (int j = 1; j <= days; j++) {
        System.out.println("  Days: " + j);
    }
    i++;//NEED TO INCREMENT
}</code></pre>
    <p>We can see that the output of both examples are the same.</p>

    <p>Example: Nested loops to create a pattern</p>

    <p>We can use the nested loop in Java to create <b>patterns</b> like full pyramid, half pyramid, inverted pyramid, and so on.
      <br><br>
      Here is a program to create a half pyramid pattern using nested loops:</p>

      <pre><code class="language-java">public static void main(String [] args) {
    int rows = 5;
    
    // outer loop
    for (int i = 1; i <= rows; ++i) {
    
        // inner loop to print the numbers
        for (int j = 1; j <= i; ++j) {
            System.out.print(j + " ");
        }
        System.out.println();
    }
}</code></pre>


          </article>
    <br />
        <header>The Difference Between for, while, do/while Loops</header>
        <article>
          <p>There are several differences among the three types of loops in Java, such as the syntax, optimal time to use, condition checking, and so on. 
            The table below represents some of the primary dissimilarities between all the loops in Java.</p>


            <table>
              <tr>
                <th></th>
                <th>for Loop</th>
                <th>while Loop</th>
                <th>do/while Loop</th>
              </tr>
              <tr>
                <td><b>About</b></td>
                <td>the for loop <b>iterates a given set of statements multiple times</b></td>
                <td>the while loop <b>executes a set of instructions until a boolean condition is met</b></td>
                <td>the do/while loop <b>executes a set of statements at least once</b>, <b>even if the condition is not met</b>. 
                  After the <b></b>first execution, repeats the iteration until the boolean condition is met</b></td>
              </tr>
              <tr>
                <td><b>Best time to use</b></td>
                <td>when you know <b>the exact number of times</b> to execute this particular part of the program.</td>
                <td>when you don't know how many times you want the iteration to repeat but <b>you know when it should stop (a sentinel value)</b></td>
                <td>when you don't know how many times you want the iteration to repeat (like the while loop), but it <b>should execute at least one time</b></td>
              </tr>
              
            </table>

          

          </article>

        <br />
        <hr />
    </section>


    <!--WEEK 7 NOTES-->
    <!--Week 7 Day 2-->
    <section class="main-section" id="Characters">
      <br />
      <header><b>Characters</b></header>
      <article>
      <p>We have learned a bit about characters before (see: <b>The char Data Type</b>) as another means of choice input, however, they can be used for 
        so much more! <br><br>But first, what are characters anyway?</p>
        <p>We can think of a <b>char</b> in Java as a single letter in a word – it represents a <b>single character</b>, and it's a fundamental part of Java programming.</p>
      <p>To declare and use a char in Java, you use the char keyword before a variable name. 
        <br><br>We can then manipulate and use this char in various ways in our programs.</p> 
      <pre><code class="language-java">char letter = 'A';
System.out.println(letter);</code></pre>
      <p>In the above example, we declare a char variable named letter and assign it the value 'A'. 
        We then print out the value of letter, which outputs 'A'.</p>
     
      <p>Character literals, like 'a', appear in <b>single quotes</b>. Unlike string literals,
        which appear in double quotes (""), character literals can only contain a single
        character. Escape sequences, like '\t' or '\n', are legal because they represent a
        single character.
        <br><br>This is a key difference between chars and strings in Java.</p>

      <p>Chars are incredibly efficient in terms of memory usage. 
        <b>Each char in Java takes up only 2 bytes of memory</b>, making them a great choice when memory usage is a concern.<br><br>

        However, as previously mentioned, chars in Java can represent a single character only. 
        If we need to work with <b>multiple characters, we will need to use a string or an array of chars</b> (we'll talk about this more in a bit).
        <br><br>
        Also, remember that chars in Java are <b>case-sensitive</b>. This means that the <b>char 'a' is different from the char 'A'</b>. 
        Always be mindful of this when working with chars in Java.</p>

        <p>As you become more familiar with Java char, you'll find that there's a lot more you can do beyond simply declaring and printing them. 
          Let's delve into some of these advanced techniques, such as manipulating and comparing characters.</p>

      </article>
      <br />
      <header>Manipulating chars</header>
      <article>
      <p>We can perform arithmetic operations on chars in Java, similarly to ints and doubles. 
        This is because chars in Java are, in fact, <b>numeric values representing Unicode characters</b>. <br><br>
        The increment and decrement operators work perfectly normal with characters.
        <br><br>Here is an example:</p>
       <pre><code class="language-java">char letter = 'A';
letter++;
System.out.println(letter);</code></pre>
        <p>In the above example, we increment the char 'A' by 1, which results in the char 'B'. 
          <br><br>This is because in the Unicode character set, 'B' is one position after 'A'.</p>
        <p>The character 'A' has a Unicode value of 65, so adding 1 to it results in the Unicode value of 66 or most notably the char 'B'.</p>
        <p>We can do the same with the other arithmetic operations as well! For example, subtraction:</p>
        <pre><code class="language-java">char letter = 'W';
letter--;
System.out.println(letter); //What will this print out?</code></pre>

          <p>We can also use chars in loops, the following loop
            displays the letters of the alphabet:</p>

            <pre><code class="language-java">System.out.print("English alphabet: ");
for (char c = 'A'; c <= 'Z'; c++) {
    System.out.print(c + " ");
}
System.out.println();</code></pre>

          <p>Just like with int or double we can also cast a number to a char using typecasting. (once again, see: <b>The char Data Type</b>)</p>

      </article>
      <br />
      <header>Comparing chars</header>
      <article>
      <p>Characters work like the other primitive types we have seen. You can compare
        them using relational operators:</p>
       <pre><code class="language-java">char firstLetter = 'A';
char secondLetter = 'B';
System.out.println(firstLetter < secondLetter); //(T or F)</code></pre>
        <p>In this code snippet, we compare two chars 'A' and 'B'. Since 'A' comes before 'B' in the Unicode character set, 
          the expression 'firstLetter < secondLetter' returns <text style="color:blue"><b>true</b></text>.</p>
        <p>Since, we can use relational operators with chars we can also use them in boolean conditions such as the following:</p>
        
        <pre><code class="language-java">if (firstLetter == 'A') {
    System.out.println("The first letter is " + firstLetter);
}</code></pre>
      





<p>While the char data type is a powerful tool for handling single characters in Java, there are alternative approaches that offer additional functionality. 
  We will explore two of these: the <b>Character</b> wrapper class and using <b>Strings</b>.</p>
        
      </article>
      <br />
      <hr />
    </section>

    <section class="main-section" id="The_Character_Class">
      <br />
      <header><b>The Character Class</b></header>
      <article>
      <p>Most of the time, if you are using a single character value, you will use the primitive char type.<br><br> 
        However in programming, we come across situations where we need to use objects instead of primitive data types. 
        In order to achieve this, Java provides wrapper class <b>Character</b> for primitive data type char.</p>
        <p>Character is a <i>wrapper</i> class that "wraps" the char in a Character object.<br><br> 
          An object of type Character contains a single field, whose type is char.
          You can create a Character object with the Character constructor.<br><br>
          To create a Character object: </p> 
      <pre><code class="language-java">Character ch = new Character('A');</code></pre>
      <p>The above statement creates a Character object which contains 'A' of type char.</p>
     
      <p>This Character class also offers a number of <b>useful class (that is, static) methods</b> for manipulating characters.</p>

      <p>The following table lists some of the most useful methods in the Character class:</p>
      <table width="50%" border="1" cellpadding="4" cellspacing="3" class="structure">
      <tr>
        <th id="h1" width="50%">Method</th>
        <th id="h2">Description</th>
        </tr>
        <tr>
        <td headers="h1"><code>boolean <b>isLetter</b>(char ch)<br />
        boolean <b>isDigit</b>(char ch)</code></td>
        <td headers="h2">Determines whether the specified char value is a letter or a digit, respectively.</td>
        </tr>
        <tr>
        <td headers="h1"><code>boolean <b>isWhitespace</b>(char ch)</code></td>
        <td headers="h2">Determines whether the specified char value is white space.</td>
        </tr>
        <tr>
        <td headers="h1"><code>boolean <b>isUpperCase</b>(char ch)<br />
        boolean <b>isLowerCase</b>(char ch)</code></td>
        <td headers="h2">Determines whether the specified char value is uppercase or lowercase, respectively.</td>
        </tr>
        <tr>
        <td headers="h1"><code>char <b>toUpperCase</b>(char ch)<br />
        char <b>toLowerCase</b>(char ch)</code></td>
        <td headers="h2">Returns the uppercase or lowercase form of the specified char value.</td>
        </tr>
        <tr>
        <td headers="h1"><code><b>toString</b>(char ch)</code></td>
        <td headers="h2">Returns a String object representing the specified character value &#151; that is, a one-character string.</td>
        </tr>
        </table>



      <p>For a complete listing of all methods in this class (there are more than 50), 
        refer to the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Character.html">java.lang.Character</a> API specification.</p>

      <p>Here is an example of using the Character class to convert a char to uppercase:</p>
      <pre><code class="language-java">char lowercaseLetter = 'a';
char uppercaseLetter = Character.toUpperCase(lowercaseLetter);
System.out.println(uppercaseLetter);</code></pre>
      <p>In this example, we use the toUpperCase method of the Character class to convert the lowercase char 'a' to an uppercase 'A'.</p>


      </article>
      
      <br />
      <hr />
    </section>


    <section class="main-section" id="Strings">
      <br />
      <header><b>Strings</b></header>
      <article>
      <p>Strings are the type of objects that can store the character of values and in Java.<br><br>
         A String class object acts the same as an <b>array of characters in Java</b>. <br><br>In Java, objects of the String class 
        are <b>immutable</b> which means that they are constant and <b>cannot be changed once created</b>.</p> 
        <p>A String variable contains a collection of characters surrounded by double quotes:</p>
      <pre><code class="language-java">String greeting = "Hello!";</code></pre>



      <p>A String in Java is actually an object, which means that it contains methods that can perform certain operations on Strings. </p>

      <p>A couple of the methods, <b>toUpperCase()</b> and <b>toLowerCase()</b> convert from
uppercase to lowercase and back. These methods are often a source of confusion, because it sounds like they modify strings. But neither these methods
nor any others can change a string, because strings are immutable</p>

        <p>When you invoke <b>toUpperCase()</b> on a string, you get a new string object as a
          return value. For example:</p>

          <pre><code class="language-java">String name = "Alan Turing";
String upperName = name.toUpperCase();</code></pre>

            <p>After these statements run, upperName refers to the String <b>"ALAN TURING"</b>.
              But name still refers to <b>"Alan Turing"</b>.</p>

          <p>Another useful method is <b>replace()</b>, which finds and replaces instances of one
            String within another. This example replaces <b>"Computer Science"</b> with <b>"CS"</b>:
            </p>

            <pre><code class="language-java">String text = "Computer Science is fun!";
text = text.replace("Computer Science", "CS");</code></pre>

            <p>This example demonstrates a common way to work with String methods. <br><br>
              It invokes text.replace(), which returns <b>a reference to a new String</b>: "CS is fun!".
              Then it assigns the new string to text, replacing the old String.</p>

              <p>This assignment is important; <b>if you don’t save the return value, invoking
                text.replace() has no effect</b>.</p>

      
</article>
<br />
<header>String Traversal</header>
<article>

  <p>Strings provide a method called <b>length()</b> that returns the number of characters
    in the string.</p>

  <p>For example:</p>
  <pre><code class="language-java" style="font-size: 25px;">String fruit = "banana";
System.out.println("The length of the String is: " + fruit.length());</code></pre>

    <p>The Java String class <b>charAt</b>() method <b>returns a char value at the given index number</b>.
      <br><br>
      Since a String is technically an array of characters, <b>the index number starts from 0 and goes to n-1, 
      where n is the length of the string</b>.</p>

      <pre><code class="language-java" style="font-size: 25px;">char ch = fruit.charAt(2);//returns the char value at the 2nd index  
System.out.println(ch);</code></pre>

      <p>To find the last letter of a string, you might be tempted to try something like:</p>

      <pre><code class="language-java">int length = fruit.length();
char last = fruit.charAt(length);//wrong!</code></pre>

      <p>This code compiles and runs, but invoking the charAt method throws a
        <b>StringIndexOutOfBoundsException</b>. <br><br>The problem is that there is no letter at the sixth
        index in "banana". Since we started counting at 0, the 6 letters are indexed
        from 0 to 5. <br><br><b>To get the last character, you have to subtract 1 from length</b>.</p>
    
        <pre><code class="language-java">int length = fruit.length();
char last = fruit.charAt(length - 1);//correct!</code></pre>

        <p>Many String traversals involve reading one String and creating another. For
          example, to reverse a String, we simply add one character at a time:</p>

        <pre><code class="language-java">String reverse = "";
for (int i = fruit.length() - 1; i >= 0; i--) {
    reverse = reverse + fruit.charAt(i);
}
System.out.println(reverse);</code></pre>

      <p>The initial value of reverse is "", which is the <b>empty String</b>. <br><br>The loop traverses
        the letters of fruit in reverse order. Each time through the loop, it creates a new
        String and assigns it to reverse. When the loop exits, reverse contains the letters from fruit
        in reverse order. <br><br><b>So the result of when fruit is "banana" is "ananab"</b>.</p>
      </article>

      <br />
<header>Substrings</header>
<article>

  <p>The <b>.substring()</b> method returns <b>a new string that copies letters from an existing string, starting at the given index</b>.</p>

  <p>For example:</p>
 <ul>
  <li>fruit.substring(0) returns "banana"</li>
  <li>fruit.substring(2) returns "nana"</li>
  <li>fruit.substring(6) returns ""</li>
 </ul>

    <p>The first example returns a copy of the entire String. The second example
      returns all but the first two characters. As the last example shows, substring
      returns the empty String if the argument is the length of the String.
      </p>

      <p>To visualize how the substring method works, it helps to draw a picture like the following:</p>

      <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/String%20state%20diagram.png?raw=true" alt="state diagram"/>

      <p>Like most String methods, .substring() is overloaded. That is, there are other
        versions of .substring() that have different parameters. If it's invoked with two
        arguments, they are treated as a start and end index:</p>

        <ul>
          <li>fruit.substring(0, 3) returns "ban"</li>
          <li>fruit.substring(2, 5) returns "nan"</li>
          <li>fruit.substring(6, 6) returns ""</li>
         </ul>

        <p>Notice that the character indicated by the end index is not included. 
          Defining .substring() this way simplifies some common operations. <br><br>For example,
          to select a .substring() with length len, starting at index i, you could write
          fruit.substring(i, i + len).</p> 
 
      </article>

      <br />
<header>The .indexOf() Method</header>
<article>

  <p>The <b>.indexOf()</b> method <b>searches for a character in a String</b>.</p>

  <p>There are four variants of the .indexOf() method:</p>

  <ul>
    <li><b>int indexOf()</b></li>
      <br>
      <ul>
        <li>This method returns the index within this string of the first occurrence of the specified character or -1, 
          if the character does not occur.</li>
      </ul>
      <br>
    <li><b>int indexOf(char ch, int strt)</b></li>
    <br>
    <ul>
      <li>This method returns the index within this string of the first occurrence of the specified character, 
        starting the search at the specified index or -1, if the character does not occur.</li>
    </ul>
    <br>
    <li><b>int indexOf(String str)</b></li>
    <br>
    <ul>
      <li>This method returns the index within this string of the first occurrence of the specified substring. 
        If it does not occur as a substring, -1 is returned.</li>
    </ul>
    <br>
    <li><b>int indexOf(String str, int strt)</b></li>
    <br>
    <ul>
      <li>This method returns the index within this string of the first occurrence of the specified substring, 
        starting at the specified index. If it does not occur, -1 is returned. </li>
    </ul>
  </ul>
    
    <p>This example <b>finds the index of 'a' in the String</b>:</p>

    <pre><code class="language-java">String fruit = "banana";
int index = fruit.indexOf('a');</code></pre>

      <p>But the letter appears three times, so it's not obvious what .indexOf() should do. <br><br>According to the
        documentation, it returns the <b>index of the <i>first</i> appearance</b>.</p>

      <p>To find subsequent appearances, you can use the second version of .indexOf(), which
        takes a second argument that indicates where in the String to start looking.</p>

        <pre><code class="language-java">int index = fruit.indexOf('a', 2);</code></pre>

      <p>This code starts at index 2 (the first 'n') and finds the next 'a', which is
        at index 3. If the letter happens to appear at the starting index, the starting
        index is the answer. So fruit.indexOf('a', 5) returns 5.</p>
 
        <p>We can also find the <b>last occurrence</b> of a character. 
          The <b>.lastIndexOf()</b> method returns <b>the position of the last occurrence of specified character(s) in a String</b>.</p>

        <p>Like .indexOf(), there are four variants of the .lastIndexOf() method:</p>
        <img class="width: 100%; height: 100" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/lastIndexOf.png?raw=true" alt="lastIndexOf" />

      </article>

      <br />
<header>String Comparison</header>
<article>

  <p>To compare two Strings, it may be tempting to use the == and != operators.</p>

    <pre><code class="language-java">String name1 = "Alan Turing";
String name2 = "Ada Lovelace";
if (name1 == name2) { // wrong!
    System.out.println("The names are the same.");
}</code></pre>

      <p>This code compiles and runs, and most of the time it gets the answer right.
        <b>But it is not correct, and sometimes it gets the answer wrong</b>. <br><br>The problem is
        that the == operator checks whether the two variables refer to the same object (by comparing the references). 
        If you give it two different Strings that contain the same letters, it yields <text style="color:blue"><b>false</b></text>.
        </p>

      <p>The right way to compare Strings is with the equals method, like this:</p>

        <pre><code class="language-java">if (name1.equals(name2)) {
    System.out.println("The names are the same.");
}</code></pre>

      <p>This example invokes equals on name1 and passes name2 as an argument.
        <b>The equals method returns <text style="color:blue"><b>true</b></text> if the strings contain the same characters;
        otherwise it returns <text style="color:blue"><b>false</b></text></b>.</p>

      <p>If the Strings differ, we can use the .compareTo() method to see which comes first in alphabetical order:</p>

      <pre><code class="language-java">int diff = name1.compareTo(name2);
if (diff == 0) {
    System.out.println("The names are the same.");
} else if (diff < 0) {
    System.out.println("name1 comes before name2.");
} else if (diff > 0) {
    System.out.println("name2 comes before name1.");
}</code></pre>

      <p>The return value from .compareTo() is the difference between the first characters
        in the strings that differ.</p>

        <ul>
          <li>If the Strings are <b>equal, their difference is zero</b>.</li>
          <li>If the <b>first String (the one on which the method is invoked) comes first in the
        alphabet, the difference is negative</b>.</li>
          <li><b>Otherwise, the difference is positive</b>.</li>
        </ul>

        <p>In the preceding code, compareTo returns positive 8, because the second letter
          of "Ada" comes before the second letter of "Alan" by 8 letters.</p>

        <p>Both .equals() and .compareTo() are case-sensitive. The uppercase letters come
          before the lowercase letters, so "Ada" comes before "ada".</p>

        <p>The <b>.equalsIgnoreCase()</b> method compares two Strings, ignoring lower case and upper case differences.
          
          This method returns <text style="color:blue"><b>true</b></text> if the Strings are equal, and <text style="color:blue"><b>false</b></text> if not.
          <br><br>
          Use the <b>.compareToIgnoreCase()</b> method to compare two Strings lexicographically, ignoring case differences.</p>
        
 
      </article>

      <br />
      <header>String Formatting</header>
      <article>
      
        <p>We previously learned how to use .printf() to display formatted output.
          Sometimes programs need to create Strings that are formatted a certain way, 
          but not display them immediately, or ever.</p>

          <p>In Java, the <b>String.format()</b> method returns a formatted string using the given locale, specified format String, and arguments. 
            We can concatenate the Strings using this method and at the same time, we can format the output concatenated String.</p>
            
          <p><b>String.format()</b> takes the same arguments as <b>System.out.printf()</b>: 
            a format specifier followed by a sequence of values. <br><br>The main difference is that while
            <b>System.out.printf() displays the result on the screen</b>, <b>String.format() creates
            a new String, but does not display anything</b>.</p>
      
            
            </article>

            <br />
      <header>Wrapper Classes</header>
      <article>
      
        <p>Primitive values (like ints, doubles, and chars) do not provide methods. For
          example, you can't call equals on an int:</p>

          <pre><code class="language-java">int i = 5;
System.out.println(i.equals(5)); // compiler error</code></pre>

          <p>But for each primitive type, <b>there is a corresponding class in the Java library,
            called a wrapper class</b>. We already spoke a bit about the wrapper class for char, <b>Character</b>. <br><br>For
            int it is called <b>Integer</b>. Other wrapper classes include Boolean, Long, and
            Double. They are in the java.lang package, so <b>you can use them without
            importing them</b>.</p>
            
          <p>Each wrapper class defines constants MIN_VALUE and MAX_VALUE. For example,
            Integer.MIN_VALUE is -2147483648, and Integer.MAX_VALUE is 2147483647.
            <b>Because these constants are available in wrapper classes, you don't have to
            remember them, and you don't have to include them in your programs</b>.</p>

          
            <p>Wrapper classes provide methods for converting Strings to other types. For
              example, <b>Integer.parseInt()</b> converts a String to (you guessed it) an integer:
              </p>

            <pre><code class="language-java">String str = "12345";
int num = Integer.parseInt(str);</code></pre>
      
            <p>In this context, parse means something like “read and translate”. <br><br>
              The other wrapper classes provide similar methods, like <b>Double.parseDouble()</b>
              and <b>Boolean.parseBoolean()</b>. They also provide .toString(), which returns a
              String representation of a value:</p>

              <pre><code class="language-java">int num = 12345;
String str = Integer.toString(num);</code></pre>

                <p>The result is the String "12345".</p>
            
            </article>

      <br />
      <hr />
    </section>



    <section class="main-section" id="Methods">
      <br />
      <header><b>Methods</b></header>
      <article>
        <p>So far we have only written short programs that have a single class and a <b>single
          method (main)</b>. </p>

        <p>Now, we will expand our programs to utilize more than one method. But first, what is a method anyway?</p>

        <p>A <b>method</b> in Java is <b>a block of code that, when called, performs specific actions mentioned in it.</b>
          <br><br>For instance, if you have written instructions to draw a circle in the method, it will do that task. 
          <b>You can insert values or parameters into methods, and they will only be executed when called.</b> 
          They are also referred to as functions. <br><br>The primary uses of methods in Java are:</p>
          <ul>
            <li>It allows code <b>reusability</b> (define once and use multiple times)</li>
            <li>It <b></b>breaks a complex program into smaller chunks of code</b></li>
            <li>It increases code <b>readability</b></li>
          </ul>

          <p>We have seen methods before through our use of class objects. Classes such as Math, Character, and Scanner all have methods that help 
            us simplify the work we need to do as programmers.</p>
            
          <p>In mathematics, you have probably seen functions like sin and log, and you
            have learned to evaluate expressions like sin(π/2) and log(1/x).First, you
            evaluate the expression in parentheses, which is called the argument of the
            function. Then you can evaluate the function itself, maybe by punching it into
            a calculator.</p>

          <p>Remember, we can use, or <b>invoke</b>, Math methods like this:</p>

          <pre><code class="language-java">double root = Math.sqrt(17.0);
double angle = 1.5;
double height = Math.sin(angle);</code></pre>

            <p>The first line sets root to the square root of 17. The third line finds the sine
              of 1.5 (the value of angle).</p>

            <p>We can change the values passed as arguments to these methods and they will use the same approach to compute the result based on this 
              new value. That reusability is one of the main benefits of methods.</p>

      
</article>
<br />
<header>Composition</header>
<article>

  <p>Just as with mathematical functions, Java methods can be <b><i>composed</i></b>. That
    means <b>you can use one expression as part of another</b>. For example, you can
    use any expression as an argument to a method:</p>

    <pre><code class="language-java">double x = Math.cos(angle + Math.PI / 2.0);</code></pre>

    <p>This statement divides Math.PI by two, adds the result to angle, and computes the cosine of the sum. 
      You can also take the result of one method and pass it as an argument to another:</p>

      <pre><code class="language-java">double y = Math.exp(Math.log(10.0));</code></pre>  

    <p>In Java, the log method always uses base e. So this statement finds the log
      base e of 10, and then raises e to that power. The result gets assigned to y.</p>

      <p>Some Math methods take more than one argument. For example, Math.pow()
        takes two arguments and raises the first to the power of the second. This line
        of code assigns the value 1024.0 to the variable z:
        </p>

        <pre><code class="language-java">double z = Math.pow(2.0, 10.0);</code></pre>

        <p>When using Math methods, it is a common error to forget the Math. For
          example, if you try to invoke pow(2.0, 10.0), you get an error message like:</p>

          <img style="width:100%; height:100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Math%20class%20error.png?raw=true" alt="Math class error"/>

        <p>The message "cannot find symbol" is confusing, but the last line provides a
          useful hint. The compiler is looking for pow in the same class where it is used,
          which is Test. <b>If you don't specify a class name, the compiler looks in the
          current class</b>.</p>

      </article>

      <br />
<header>Adding New Methods</header>
<article>

  <p>You have probably guessed by now that we can define more than one method
    in a class, meaning that we can define our own methods for functionality.</p>

    <p>There are a total of six components included in a method declaration. The components provide various information about the method:</p>

    <ol>
      <li><b>Access Specifier</b></li>
      <ul>
        <br>
        <li>This is used to define the access type of the method. Every method we write in this course will be <b>public</b>, however, Java provides four different specifiers, 
          which are: </li>
          <ul>
            <br>
            <li><b>public</b>: You can access it from any class</li>
            <li><b>private</b>: You can access it within the class where it is defined</li>
            <li><b>protected</b>: Accessible only in the same package or other subclasses in another package</li>
            <li><b>default</b>: It is the default access specifier used by the Java compiler if we don't mention any other specifiers. 
              It is accessible only from the package where it is declared</li>
          </ul>
      </ul>
      <br>
      <li><b>Return Type</b></li>
      <ul>
        <br>
        <li>This defines the return type of the method. We can declare the return type as void if the method returns no value.</li>
      </ul>
      <br>
      <li><b>Method Name</b></li>
      <ul>
        <br>
        <li>This is used to give a unique name to the method. It will be referred by this name when we invoke it.</li>
      </ul>
      <br>
      <li><b>Parameter List</b></li>
      <ul>
        <br>
        <li>This is a list of arguments (data type and variable name) that will be used in the method. 
          It can also be kept blank if we don't want to use any parameters in the method.</li>
      </ul>
      <br>
      <li><b>Method Signature</b></li>
      <ul>
        <br>
        <li>The method signature is just a combination of the method name and parameter list.</li>
      </ul>
      <br>
      <li><b>Method Body</b></li>
        <ul>
          <br>
          <li>This is the set of instructions enclosed within curly brackets that the method will perform.</li>
        </ul>
    </ol>

    <p>Here's an example:</p>

    <pre><code class="language-java">public class NewLine {
    public static void newLine() {
        System.out.println();
    }

    public static void main(String [] args) {
        System.out.println("First line.");
        newLine(); //this is a method call 
        System.out.println("Second line.");
    }
}</code></pre>

    <p>The name of the class is NewLine. By convention, <b>class names begin with a
      capital letter</b>. NewLine contains two methods, <b>newLine</b> and <b>main</b>. Remember
      that Java is case-sensitive, so NewLine and newLine are not the same.</p>

    <p><b>Method names should begin with a lowercase letter and use "camel case"</b>,
      which is a cute name for jammingWordsTogetherLikeThis. <b>You can use any
      name you want for methods, except main or any of the Java keywords</b>.
      </p>

      <p><b>newLine</b> and <b>main</b> are public, which means they can be invoked from other
        classes. They are both <b>static</b>. <br><br> When you declare a variable or a method as static, 
        <b>it belongs to the class</b>, rather than a specific instance. This means that only one instance of a static member exists, 
        even if you create multiple objects of the class, or if you don't create any. 
        <b>It will be shared by all objects</b>.<br><br>
        And they are both <b>void</b>, which means that they don't yield a result (unlike
        the Math methods, for example).</p>

        <p>The parentheses after the method name contain a list of variables, called <b>parameters</b>, where <b>the method stores its arguments</b>. 
          The main method has a single parameter, called <b>args</b>, which has type <b>String[]</b>. That means that whoever invokes
          main must provide an <b>array of Strings</b> (we'll get to arrays in a later chapter).
          </p>

          <p>Since newLine has no parameters, it requires no arguments, as shown when
            it is invoked in main. And because newLine is in the same class as main, we
            don't have to specify the class name.</p>

          <p>What is the output of this program?</p>

          <p> If we wanted more space between
            the two lines, we could invoke the same method repeatedly:</p>

          <pre><code class="language-java">public static void main(String [] args) {
    System.out.println("First line.");
    newLine(); //call 1
    newLine(); //call 2
    newLine(); //call 3
    System.out.println("Second line.");
}</code></pre>

        <p>Or we could write a new method that displays three blank lines:</p>

        <pre><code class="language-java">public static void threeLine() {
    newLine();
    newLine();
    newLine();
}
public static void main(String [] args) {
    System.out.println("First line.");
    threeLine();
    System.out.println("Second line.");
}</code></pre>

      <p>You can invoke the same method more than once, and you can have one method
        invoke another. In this example, <b>main invokes threeLine</b>, and <b>threeLine
        invokes newLine()</b>.</p>

        <p>Beginners often wonder why it is worth the trouble to create new methods.
          There are many reasons, but this example demonstrates a few of them:</p>

          <ul>
            <li>Creating a new method gives you an opportunity to give a name to a
              group of statements, which <b>makes code easier to read and understand</b>.</li>
            <li>Introducing new methods can <b>make a program smaller by eliminating
              repetitive code</b>. For example, to display nine consecutive new lines, you
              could invoke threeLine three times.</li>
            <li>A common problem solving technique is to break tasks down into subproblems. 
              Methods allow us to <b>focus on each sub-problem in isolation,
              and then compose them into a complete solution</b>.</li>
          </ul>

      </article>

      <br />
<header>Flow of Execution</header>
<article>

        <p>Pulling together the code from the previous section, the complete program
          looks like this:</p>

          <pre><code class="language-java">public class NewLine {
    public static void newLine() {
        System.out.println();//4, 6, 8
    }

    public static void threeLine() {
        newLine();//3
        newLine();//5
        newLine();//7
    }

    public static void main(String[] args) {
        System.out.println("First line."); //1
        threeLine(); //2
        System.out.println("Second line."); //9
    }
}</code></pre>

      <p>When you look at a class definition that contains several methods, it is tempting to read it from top to bottom. 
        But that is likely to be confusing, because
        that is not the <b>flow of execution</b> of the program.</p>

      <p><b>Execution always begins at the first statement of main, regardless of where it
        is in the source file</b>. Statements are executed one at a time, in order, until you
        reach a method invocation, which you can think of as a detour. <b>Instead of
        going to the next statement, you jump to the first line of the invoked method,
        execute all the statements there, and then come back and pick up exactly
        where you left off</b>.</p>

      <p>That sounds simple enough, but remember that one method can invoke another one. 
        In the middle of <b>main</b>, we go off to execute the statements in
        threeLine. While we are executing <b>threeLine</b>, we go off to execute <b>newLine</b>.
        Then newLine invokes println, which causes yet another detour.</p>

        <p>Fortunately, Java is good at keeping track of which methods are running.
          So <b>when println() completes, it picks up where it left off in newLine; when
          newLine completes, it goes back to threeLine, and when threeLine completes, it gets back to main</b>.</p>

          <p>In summary, when you read a program, don't read from top to bottom. Instead, <b>follow the flow of execution</b>.</p>

      </article>

      <br />
<header>Parameters and Arguments</header>
<article>
      <p>Some of the methods we have used require arguments, which are the values
        you provide when you invoke the method. For example, to find the square root of
        a number, you have to provide the number, so Math.sqrt() takes a double as an
        argument. <br><br>To display a message, you have to provide the message, so println
        takes a String.</p>

        <p><b>When you use a method, you provide the arguments. When you write a
          method, you name the parameters.</b> The parameter list indicates what arguments are required. 
          <br><br>The following shows an example:</p>

        <pre><code class="language-java">public static void printTwice(String s) {
    System.out.println(s);
    System.out.println(s);
}
public static void main(String [] args) {
    printTwice("Don't make me say this twice!");
}</code></pre>


  <p><b>printTwice</b> has a parameter named s with type String. When we invoke
    <b>printTwice</b>, we have to <b>provide an argument with type String</b>.</p>

    <p>Before the method executes, the argument gets assigned to the parameter.
      In this example, <b>the argument "Don't make me say this twice!" gets assigned to the parameter s</b>.</p>

    <p>This process is called <b>parameter passing</b> because the value gets passed from
      outside the method to the inside. An argument can be any kind of expression,
      so if you have a String variable, you can use it as an argument:</p>

    <pre><code class="language-java">String argument = "Never say never.";
printTwice(argument);</code></pre>

      <p>The value you provide as an argument <b>must have the same type as the parameter</b>. For example, if you try:</p>

      <pre><code class = "language-java">printTwice(17); // syntax error</code></pre>

      <p>You will get an error message.</p>

      <p>Sometimes Java can convert an argument from one type to another automatically. 
        <br><br>For example, <b>Math.sqrt()</b> requires a double, but if you invoke
        Math.sqrt(25), the integer value 25 is automatically converted to the floating point value 25.0. 
        But in the case of printTwice, Java can't (or won't) convert
        the integer 17 to a String.</p>

        <p><b>Parameters and other variables only exist inside their own methods</b>. Inside
          main, there is no such thing as s. If you try to use it there, you'll get a compiler
          error. Similarly, inside printTwice there is no such thing as argument. That
          variable belongs to main.</p>

          <p>Because variables only exist inside the methods where they are defined, they
            are often called <b>local variables</b>.</p>

      </article>

      <br />
      <header>Multiple parameters</header>
      <article>
        <p>Here is an example of a method that takes two parameters:</p>

        <pre><code class="language-java">public static void printTime(int hour, int minute) {
    System.out.print(hour);
    System.out.print(":");
    System.out.println(minute);
}</code></pre>
    
        <p>In the parameter list, it may be tempting to write:</p>

        <pre><code class="language-java">public static void printTime(int hour, minute) {</code></pre>

        <p>But that format (without the second int) is only legal for variable declarations.
          In parameter lists, you need to specify the type of each variable separately.</p>

        <p>To invoke this method, we have to provide two integers as arguments:</p>

        <pre><code class="language-java">int hour = 11;
int minute = 59;
printTime(hour, minute);</code></pre>

          <p>A common error is to declare the types of the arguments, like this:</p>

          <pre><code class="language-java">int hour = 11;
int minute = 59;
printTime(int hour, int minute); // syntax error</code></pre>

          <p>That's a syntax error; the compiler sees int hour and int minute as variable
            declarations, not expressions. You wouldn't declare the types of the arguments
            if they were simply integers:</p>

            <pre><code class="language-java">printTime(int 11, int 59); // syntax error</code></pre>

            </article>

            <br />
      <header>Stack Diagrams</header>
      <article>
      <p>Pulling together the code fragments from the previous section, here is a complete class definition:</p>

      <pre><code class="language-java">public class PrintTime {
    public static void printTime(int hour, int minute) {
        System.out.print(hour);
        System.out.print(":");
        System.out.println(minute);
    }
    public static void main(String[] args) {
        int hour = 11;
        int minute = 59;
        printTime(hour, minute);
    }
}</code></pre>

      <p><b>printTime</b> has two parameters, named <b>hour</b> and <b>minute</b>. And <b>main</b> has two
        variables, <b>also named hour and minute</b>. <br><br><b>Although they have the same names,
        these variables are not the same</b>. hour in printTime and hour in main refer
        to <b>different storage locations</b>, and <b>they can have different values</b>.</p>

        <p>For example, you could invoke printTime like this:</p>

        <pre><code class="language-java">int hour = 11;
int minute = 59;
printTime(hour + 1, 0);</code></pre>

          <p>Before the method is invoked, Java evaluates the arguments; in this example,
            the results are 12 and 0. Then it assigns those values to the parameters. Inside
            printTime, the value of hour is 12, not 11, and the value of minute is 0, not
            59. <br><br>Furthermore, if printTime modifies one of its parameters, <b>that change
            has no effect on the variables in main</b>.</p>

          <p>One way to keep track of everything is to draw a <b>stack diagram</b>, which is
            a state diagram that shows method invocations. <br><br>For each
            method there is a box called a frame that contains the method's parameters and variables. 
            The name of the method appears outside the frame; the
            variables and parameters appear inside.</p>

          <p>As with state diagrams, stack diagrams show variables and methods at a particular point in time. 
            The following is a stack diagram at the beginning of the
            printTime method.</p>

          <img style="width: 80%; height: 80%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/stack%20diagram.png?raw=true" alt="stack diagram"/>
  
            </article>
      <br />
      <header>Writing Documentation</header>
      <article>
          <p> A nice feature of the Java language is the
            <b>ability to embed documentation in your source code</b>. That way, you can write
            it as you go, and as things change, it is easier to keep the documentation
            consistent with the code.</p>

          <p>If you include documentation in your source code, you can extract it automatically, 
            and generate well-formatted HTML, using a tool called <b>Javadoc</b></p>

          <p>This tool is included in standard Java development environments, and it is widely used. 
            In fact, the online documentation of the Java libraries is generated by
            Javadoc.</p>

          <p>Javadoc scans your source files looking for specially-formatted <b>documentation comments</b>, also known as “Javadoc comments”. 
            They begin with <b>/**</b> (two stars) and end with <b>*/</b> (one star). Anything in between is considered
            part of the documentation.</p>

          <p>Here's a class definition with two Javadoc comments, one for the class and one
            for the main method:</p>

          <pre><code class="language-java">/**
 * Example program that demonstrates print vs println.
 */
public class Goodbye {
    /**
     * Prints a greeting.
     */
    public static void main(String [] args) {
        System.out.print("Goodbye, "); // note the space
        System.out.println("cruel world");
    } 
}</code></pre>

      <p>The <b>class comment explains the purpose of the class</b>. The <b>method comment
        explains what the method does</b>.</p>

        <p>Notice that this example also includes an <b>inline comment</b>, <b>beginning with
          //</b>. In general, <b>inline comments are short phrases that help explain complex
          parts of a program</b>. They are intended for other programmers reading and
          maintaining the source code.</p>

        <p>In contrast, <b>Javadoc comments are longer, usually complete sentences</b>. They
          <b>explain what each method does, but they omit details about how the method
          works</b>. And they are <b>intended for people who will use the methods without
          looking at the source code</b>.</p>

        <p>Appropriate comments and documentation are essential for making source
          code readable. And remember that <b>the person most likely to read your code
          in the future, and appreciate good documentation, is you</b>.</p>

      </article>
      <br />
      <header>Value Methods</header>
      <article>
        <p>Some of the methods we have used, like the Math methods, return values. But
          all the methods we have written so far have been <b>void</b>; that is, <b>they don't
          return values</b>. Now, we will begin discuss how to write methods that return values, which
          we call value methods.</p>
        
      </article>
      <br />
      <header>Return Values</header>
      <article>
       <p>When you invoke a void method, the invocation is usually on a line all by
        itself.</p>

        <p>For example, here is a recursive method called countDown():</p>

        <pre><code class="language-java">public static void countDown(int n) {
    if (n == 0) {
        System.out.println("Blastoff!");
    } else {
        System.out.println(n);
        countDown(n - 1);
    }
}</code></pre>

        <p>And here is how it is invoked:</p>

        <pre><code class="language-java">countDown(3);</code></pre>

        <p>On the other hand, <b>when you invoke a value method, you have to do something
          with the return value.</b> We usually <b>assign it to a variable or use it as part of
          an expression</b>, like this:</p>

        <pre><code class="language-java">double error = Math.abs(expected - actual);
double height = radius * Math.sin(angle);</code></pre>

        <p>Compared to void methods, value methods differ in two ways:</p>
          <ul>
            <li>They declare the type of the return value (the return type);</li>
            <li>They use at least one return statement to provide a <b>return value</b>.</li>
          </ul>

        <p>Here's an example: <b>calculateArea()</b> takes a double as a parameter and returns
          the area of a circle with that radius:</p>

        <pre><code class="language-java">public static double calculateArea(double radius) {
    double result = Math.PI * radius * radius;
    return result;
}</code></pre>

      <p>As usual, this method is <b>public</b> and <b>static</b>. But in the place where we are
        used to seeing <b>void</b>, we see <b>double</b>, which means that <b>the return value from
        this method is a double</b>.</p>

        <p>The last line is a new form of the return statement that <b>includes a return
          value</b>. <b>This statement means, "return immediately from this method and use
          the following expression as the return value."</b><br><br>The expression you provide can
          be arbitrarily complex, so we could have written this method more concisely:</p>

        <pre><code class="language-java">public static double calculateArea(double radius) {
    return Math.PI * radius * radius;
}</code></pre>
            
      <p>On the other hand, temporary variables like result often make debugging
        easier, especially when you are stepping through code using an interactive
        debugger.</p>

      <p>The type of the expression in the return statement <b>must match the return
        type of the method</b>. When you declare that the return type is double, you are
        making a promise that this method will eventually produce a double value.</p>

       <p>If you try to return with no expression, or an expression with the wrong type,
        the compiler will generate an error.</p>

      <p>Sometimes it is useful to have multiple return statements, for example, one in
        each branch of a conditional:</p>

      <pre><code class="language-java">public static double absoluteValue(double x) {
    if (x < 0) {
        return -x;
    } else {
        return x;
    }
}</code></pre>

    <p>Since these return statements are in a conditional statement, only one will be
      executed. As soon as either of them executes, the method terminates without
      executing any more statements.</p>

    <p>Code that appears after a return statement (in the same block), or any place
      else where it can never be executed, is called <b>dead code</b>. The compiler will
      give you an "unreachable statement" error if part of your code is dead. <br><br>For
      example, this method contains dead code:</p>

    <pre><code class="language-java">public static double absoluteValue(double x) {
    if (x < 0) {
        return -x;
    } else {
        return x;
    }
    System.out.println("This line is dead.");
}</code></pre>

    <p><b>If you put return statements inside a conditional statement, you have to
      make sure that <i>every possible path</i> through the program reaches a return
      statement</b>. The compiler will let you know if that's not the case. <br><br>For example,
      the following method is incomplete:</p>

      <pre><code class="language-java">public static double absoluteValue(double x) {
    if (x < 0) {
        return -x;
    } else if (x > 0) {
        return x;
    }
    // syntax error
}</code></pre>

    <p>When x is 0, neither condition is true, so the method ends without hitting
      a return statement. <b>The error message in this case might be something like
      "missing return statement", which is confusing since there are already two of
      them. But hopefully you will know what it means.</b></p>

      </article>
      <br />
      <header>Writing Methods</header>
      <article>
        <p>Beginners often make the mistake of writing a lot of code before they try to
          compile and run it. Then they spend way too much time debugging. A better
          approach is what we call <b>incremental development</b>. <br><br>The key aspects of
          incremental development are:</p>
          <ul>
            <li>Start with a working program and make small, incremental changes. At
              any point, if there is an error, you will know where to look.</li>
            <li>Use variables to hold intermediate values so you can check them, either
              with print statements or by using a debugger.</li>
            <li>Once the program is working, you can consolidate multiple statements
              into compound expressions (but only if it does not make the program
              more difficult to read).</li>
          </ul>

          <p>As an example, suppose you want to find the distance between two points,
            given by the coordinates (x1, y1) and (x2, y2). By the usual definition:</p>

            <img style="width: 100%; height: 80%" src="https://raw.githubusercontent.com/amaraauguste/amaraauguste.github.io/ea3c4bf85e0d3dc97218c229ad9e719bddb778c2/courses/CISC1115/images/distance_formula.svg" alt="distance formula"/>

          <p>The first step is to consider what a distance method should look like in Java.
            In other words, what are the inputs (parameters) and what is the output (return value)? 
            In this case, <b>the two points are the parameters, and it is
            natural to represent them using four double values</b>. <b>The return value is the
            distance, which should also have type double</b>.</p>

          <p>Already we can write an outline for the method, which is sometimes called a
            stub. The stub includes the method signature and a return statement:</p>

          <pre><code style="font-size: 23.5px" class="language-java">public static double distance(double x1, double y1, double x2, double y2) {
    return 0.0;
}</code></pre>

          <p>The return statement is <b>a placeholder that is necessary for the program to
            compile</b>. At this stage the program doesn't do anything useful, but it is good
            to compile it so we can find any syntax errors before we add more code.</p>

          <p>It's usually a good idea to think about testing <i>before</i> you develop new methods;
            doing so can help you figure out how to implement them. To test the method,
            we can invoke it from main using sample values:</p>

          <pre><code class="language-java">double dist = distance(1.0, 2.0, 4.0, 6.0);</code></pre>

          <p>With these values, the horizontal distance is 3.0 and the vertical distance is
            4.0. So the result should be 5.0, the hypotenuse of a 3-4-5 triangle. <b>When you
            are testing a method, it is helpful to know the right answer</b>.</p>

          <p>Once we have compiled the stub, we can start adding lines of code one at a
            time. After each incremental change, we recompile and run the program. If
            there is an error at any point, we have a good idea where to look: the last line
            we added.</p>

          <p>The next step is to find the differences <b>x2 − x1</b> and <b>y2 − y1</b>. We store those
            values in temporary variables named <b>dx</b> and <b>dy</b>.</p>

          <pre><code style="font-size: 23.5px" class="language-java">public static double distance(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    System.out.println("dx is " + dx);
    System.out.println("dy is " + dy);
    return 0.0;
}</code></pre>

          <p>The print statements allows us to check the intermediate values before proceeding. 
            They should be 3.0 and 4.0. We will remove the print statements
            when the method is finished. Code like that is called <b>scaffolding</b>, because it
            is helpful for building the program, but it is not part of the final product.</p>

          <p>The next step is to square dx and dy. We could use the Math.pow method,
          but it is simpler to multiply each term by itself.</p>

          <pre><code style="font-size: 23.5px" class="language-java">public static double distance(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    System.out.println("dsquared is " + dsquared);
    return 0.0;
}</code></pre>

        <p>Again, you should compile and run the program at this stage and check the
          intermediate value, which should be 25.0. Finally, we can use Math.sqrt to
          compute and return the result.</p>

        <pre><code style="font-size: 23.5px" class="language-java">public static double distance(double x1, double y1, double x2, double y2) {
    double dx = x2 - x1;
    double dy = y2 - y1;
    double dsquared = dx * dx + dy * dy;
    double result = Math.sqrt(dsquared);
    return result;
}</code></pre>

        <p>As you gain more experience programming, you might write and debug more
          than one line at a time. Nevertheless, incremental development can save you
          a lot of time.</p>

      </article>
      <br />
      <header>Method Composition</header>
      <article>
        <p>Once you define a new method, you can use it as part of an expression, or
          build new methods using existing methods. <br><br>For example, suppose someone
          gave you two points, the <b>center of the circle</b> and <b>a point on the perimeter</b>,
          and asked for the <b>area</b> of the circle. Let's say the center point is stored in the
          variables <b>xc and yc</b>, and the perimeter point is in <b>xp and yp</b>.</p>

        <p>The first step is to find the radius of the circle, which is the distance between
          the two points. Fortunately, we have just written a method that does just that (distance).</p>
      
        <pre><code class="language-java">double radius = distance(xc, yc, xp, yp);</code></pre>

        <p>The second step is to find the area of a circle with that radius. We have a written a method 
          for that computation too (calculateArea).</p>

        <pre><code class="language-java">double area = calculateArea(radius);
return area;</code></pre>

          <p>Putting everything together in a new method, we get:</p>

          <pre><code style="font-size: 22px" class="language-java">public static double circleArea(double xc, double yc, double xp, double yp) {
    double radius = distance(xc, yc, xp, yp);
    double area = calculateArea(radius);
    return area;
}</code></pre>

        <p>The temporary variables radius and area are useful for development and
          debugging, but once the program is working we can make it more concise by
          composing the method calls:</p>

        <pre><code style="font-size: 22px" class="language-java">public static double circleArea(double xc, double yc, double xp, double yp) {
    return calculateArea(distance(xc, yc, xp, yp));
}</code></pre>
 
      <p>This example demonstrates a process called <b>functional decomposition</b>; that
        is, breaking a complex computation into simple methods, testing the methods
        in isolation, and then composing the methods to perform the computation.
        This process reduces debugging time and yields code that is more likely to be
        correct and easier to maintain.</p>

      </article>
      <br />
      <header>Overloading</header>
      <article>
        <p>You might have noticed that circleArea and calculateArea perform similar
          functions. They both find the area of a circle, but they take different parameters. 
          For <b>calculateArea, we have to provide the radius</b>; for <b>circleArea we
          provide two points</b>.</p>

        <p>If two methods do the same thing, it is natural to give them the same name.
          Having more than one method with the same name is called <b>overloading</b>,
          and it is legal in Java <b>as long as each version takes different parameters</b>. So
          we could rename circleArea to calculateArea:</p>

          <pre><code style="font-size: 22px" class="language-java">public static double calculateArea(double xc, double yc, double xp, double yp) {
    return calculateArea(distance(xc, yc, xp, yp));
}</code></pre>

        <p>Note that this new calculateArea method is <b>not recursive</b>. <b>When you invoke
          an overloaded method, Java knows which version you want by looking at the
          arguments that you provide</b>. If you write:</p>

        <pre><code class="language-java">double x = calculateArea(3.0);</code></pre>

        <p>Java looks for <b>a method named calculateArea that takes one double as an
          argument</b>, and so it uses the first version, which <b>interprets the argument as a
          radius</b>. If you write:</p>

        <pre><code class="language-java">double y = calculateArea(1.0, 2.0, 4.0, 6.0);</code></pre>

        <p>Java uses <b>the second version of calculateArea, which interprets the arguments as two points</b>. 
          In this example, the second version actually invokes the first version.</p>

        <p><b>Many Java methods are overloaded, meaning that there are different versions
          that accept different numbers or types of parameters</b>. For example, there are
          versions of print and println that accept a single parameter of any data
          type. In the Math class, there is a version of abs that works on doubles, and
          there is also a version for ints.</p>

        <p>Although overloading is a useful feature, <b>it should be used with caution</b>. You
          might get yourself nicely confused if you are trying to debug one version of a
          method while accidentally invoking a different one.</p>
            
      </article>
      <br />
      <header>Boolean Methods</header>
      <article>
        <p>Methods can return <text style="color:blue"><b>boolean</b></text> values, just like any other type, which is often
          convenient for hiding tests inside methods. <br><br>For example:</p>

        <pre><code class="language-java">public static boolean isSingleDigit(int x) {
    if (x > -10 && x < 10) {
        return true;
    } else {
        return false;
    }
}</code></pre>

      <p>The name of this method is <b>isSingleDigit()</b>. It is common to give <text style="color:blue"><b>boolean</b></text> 
        methods names that <b>sound like yes/no questions</b>. Since the return type is
        <text style="color:blue"><b>boolean</b></text> , 
        <b>the return statement has to provide a <text style="color:blue"><b>boolean</b></text> expression</b>.</p>

      <p>The code itself is straightforward, although it is longer than it needs to be.
        Remember that the expression <b>x > -10 && x < 10</b> has type <text style="color:blue"><b>boolean</b></text>, so there
        is nothing wrong with <b>returning it directly</b> (without the if statement):</p>

      <pre><code class="language-java">public static boolean isSingleDigit(int x) {
    return x > -10 && x < 10;
}</code></pre>

    <p>In main, you can invoke the method in the usual ways:</p>

    <pre><code class="language-java">System.out.println(isSingleDigit(2));
boolean bigFlag = !isSingleDigit(17);</code></pre>

      <p>The first line displays <text style="color:blue"><b>true</b></text> because 2 is a single-digit number. The second
        line sets bigFlag to <text style="color:blue"><b>true</b></text>, because 17 is not a single-digit number.</p>

      <p>Conditional statements often invoke <text style="color:blue"><b>boolean</b></text> methods and use the result as
        the condition:</p>

    <pre><code class="language-java">if (isSingleDigit(z)) {
    System.out.println("z is small");
} else {
    System.out.println("z is big");
}</code></pre>

    <p>Examples like this one almost read like English: "If is single digit z, print ...
      else print ...".</p>
     
      </article>
      <br />
      <header>Javadoc Tags</header>
      <article>
        <p>We discussed how to write documentation comments using /**.
          It's generally a good idea to document each class and method, so that other
          programmers can understand what they do without having to read the code.</p>


          <p>To organize the documentation into sections, Javadoc supports optional tags
            that begin with the at sign (@). For example, we can use @param and @return
            to provide additional information about parameters and return values.
            </p>

          <pre><code class="language-java">/**
  * Tests whether x is a single digit integer.
  *
  * @param x the integer to test
  * @return true if x has one digit, false otherwise
  */
public static boolean isSingleDigit(int x) {</code></pre>

        <p>The following shows part of the resulting HTML page generated by Javadoc.
          Notice the relationship between the source code and the documentation:</p>

        <img style="width: 100%; height: 100%" src = "https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/javadoc.png?raw=true" alt="Javadoc"/>
      
        <p>Methods with multiple parameters should have <b>separate @param tags that
          describe each one</b>. <b>Void methods should have no @return tag</b>, since they do
          not return a value.</p>

        
            
      </article>
    
      <br />
      <hr />
    </section>


    <section class="main-section" id="Arrays">
      <br />
      <header><b>Arrays</b></header>
      <article>
        
        <p>An <b>array</b> is <b>a sequence of values</b>; <b>the values in the array are called elements</b>.</p>

        <p>Conceptually this might sound familiar, <b>internally Strings are 
          represented by a char array</b> with an offset and length (this allows to create lightweight substrings, using the same char arrays).</p>

      <p>However, Strings are actually immutable objects representing a character sequence (CharSequence is one of the interfaces implemented by String). 
        The main difference to char arrays and collections of chars is that <b>Strings cannot be modified, 
        so it's not possible (ignoring reflection) to add/remove/replace characters</b>.</p>

      <p><b>You can make an array of ints, doubles, or any other type, but all the values
        in an array must have the same type</b>.</p>

</article>
<br />
<header>Creating Arrays</header>
<article>

  <p>To create an array, we have to <b>declare a variable with an <i>array type</i> and then
    create the array itself</b>. Array types look like other Java types, except <b>they are
    followed by square brackets ([])</b>. <br><br>For example, the following lines declare that
    <b>counts</b> is an "integer array" and <b>values</b> is a "double array":</p>

    <pre><code class="language-java">int [] counts;
double [] values;</code></pre>

      <p>To create the array itself, <b>we have to use the new operator</b>, which we have seen with Scanner and PrintWriter:</p>

      <pre><code class="language-java">counts = new int [4];
values = new double [size];</code></pre>

      <p>The first assignment <b>makes count refer to an array of four integers</b>. The second
        <b>makes values refer to an array of double, where the number of elements in
        values depends on the value of size</b>.</p>

        <p>Of course, we can also declare the variable and create the array in a single
          line of code:</p>

        <pre><code class="language-java">int [] counts = new int [4];
double [] values = new double [size];</code></pre>

          <p><b>You can use any integer expression for the size of an array, as long as the value
            is nonnegative</b>. If you try to create an array with -4 elements, for example,
            you will get a NegativeArraySizeException. <b>An array with zero elements is
            allowed, and there are special uses for such arrays that we'll see later on</b>.</p>


          <p>Another way to create an array is to use an <b>initializer list</b>. 
            You can initialize (set) the values in the array to a list of values in curly brackets { } 
            when you create it, like below. In this case <b>you don't specify the size of the array, 
            it will be determined from the number of values that you specify</b>.</p>

            <p>For example:</p>

            <pre><code class="language-java">int [] counts = {0, 0, 0, 0};</code></pre>
      </article>

      <br />
<header> Accessing Elements</header>
<article>

  <p>When you create an array of ints, <b>the elements are initialized to zero</b>. 
    The following is a state diagram of the counts array so far:</p>

    <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/array%20stack%201.png?raw=true" alt="array initial state diagram"/>

    <p>The arrow indicates that the value of counts is a <b>reference</b> to the array.
You should think of the array and the variable that refers to it as two different
things. As we’ll soon see, <b>we can assign a different variable to refer to the same
array, and we can change the value of counts to refer to a different array</b>.</p>


    <p>The large numbers inside the boxes are the elements of the array. The small
numbers outside the boxes are the <b>indexes</b> (or indices) used to identify each
location in the array. <b>Notice that the index of the first element is 0, not 1, as
you might have expected. (We should remember this from Strings!)</b></p>

  <p>The [] operator selects elements from an array:</p>


    <pre><code class="language-java">System.out.println("The zeroth element is " + counts[0]);</code></pre>

    <p>You can use the [] operator anywhere in an expression:</p>

          <pre><code class="language-java">counts[0] = 7;
counts[1] = counts[0] * 2;
counts[2]++;
counts[3] -= 60;</code></pre>

        <p>The following shows the result of these statements:</p>

        <img style="width: 80%; height: 80%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/array%20stack%202.png?raw=true" alt="array update state diagram"/>

        <p><b>You can use any expression as an index, as long as it has type int</b>. <br><br>One of the
most common ways to index an array is with a loop variable. <br><br>For example:</p>

        <pre><code class="language-java">int i = 0;
while (i < 4) {
    System.out.println(counts[i]);
    i++;
}</code></pre>

      <p>This while loop counts from 0 up to 4. When i is 4, the condition fails and
the loop terminates. So the body of the loop is only executed when i is 0, 1,
2, and 3.</p>

        <p>Each time through the loop we use i as an index into the array, displaying the
ith element. This type of array processing is often written using a for loop</p>

          <pre><code class="language-java">for (int i = 0; i < 4; i++) {
    System.out.println(counts[i]);
}</code></pre>

      <p>For the counts array, the only legal indexes are 0, 1, 2, and 3. <b>If the index is
negative or greater than 3, the result is an ArrayIndexOutOfBoundsException</b>.</p>

      </article>

      <br />
<header>Displaying Arrays</header>
<article>

        <p>You can use println to display an array, but it probably doesn’t do what you
would like. <br><br>For example, the following fragment:</p>

          <ol>
            <li>declares an array variable,</li>
            <li>makes it refer to an array of four elements, and</li>
            <li>attempts to display the contents of the array using println:</li>
          </ol>

          <pre><code class="language-java">int [] a = {1, 2, 3, 4};
System.out.println(a);</code></pre>

      <p>Unfortunately, the output is something like: <b>[I@bf3f7e0</b></p>

      <p>The bracket indicates that the value is an array, I stands for “integer”, and
the rest represents the address of the array. <br><br><b>If we want to display the elements
of the array, we can do it ourselves:</b></p>

      <pre><code class="language-java">public static void printArray(int [] a) {
    System.out.print("{" + a[0]);
    for (int i = 1; i < a.length; i++) {
        System.out.print(", " + a[i]);
    }
    System.out.println("}");
}</code></pre>

      <p>Given the previous array, the output of this method is: <b>{1, 2, 3, 4}</b></p>

      <p>The Java library provides a utility class <b>java.util.Arrays</b> that provides
        methods for working with arrays. One of them, <b>toString()</b>, <b>returns a String
        representation of an array</b>. We can invoke it like this:</p>

      <pre><code class="language-java">System.out.println(Arrays.toString(a));</code></pre>

      <p>And the output is: <b>[1, 2, 3, 4]</b></p>

      <p>As usual, <b>we have to import java.util.Arrays before we can use it</b>. Notice
        that the String format is slightly different: it uses square brackets instead of
        curly braces. <b>However, sometimes it is beneficial for us to write our own printArray() method</b>, if we want our output formatted
        in a particular way.</p>

      </article>

      <br />
<header>Copying Arrays</header>
<article>
      <p>As previously explained, array variables contain <b>references to arrays</b>. When
        you make an assignment to an array variable, it simply <b>copies the reference</b>.
        <b>But it doesn't copy the array itself!</b> <br><br>For example:</p>

        <pre><code class="language-java">double [] a = new double [3];
double [] b = a;</code></pre>

        <p>These statements create an array of three <b>doubles</b> and make two different
          variables refer to it, as shown below:</p>

        <img style="width: 100%; height: 100%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/array%20reference.png?raw=true" alt="array ref">

        <p>Any changes made through either variable will be seen by the other. For
          example, <b>if we set a[0] = 17.0, and then display b[0], the result is 17.0</b>.
          Because a and b are different names for the same thing, they are sometimes
          called <b>aliases</b>.</p>

        <p>If you actually want to copy the array, not just a reference, you have to <b>create
          a new array and copy the elements from the old to the new</b>, like this:</p>

        <pre><code class="language-java">double [] b = new double [3];
for (int i = 0; i < 3; i++) {
    b[i] = a[i];
}</code></pre>


      </article>

      <br />
      <header>Array Length</header>
      <article>
        <p>The examples in the previous section only work if the array has three elements.
          It would be better to <b>generalize the code to work with arrays of any size</b>. We
          can do that by replacing the magic number, 3, with a.length:</p>

        <pre><code class="language-java">double [] b = new double [a.length];
for (int i = 0; i < a.length; i++) {
    b[i] = a[i];
}</code></pre>
    
        <p>All arrays have a built-in constant, <b>length</b>, that stores the number of elements.
          The expression a.length may look like a method invocation, but there are no
          parentheses and no arguments.</p>

          <p>The last time this loop gets executed, i is <b>a.length - 1</b>, which is the index
            of the <b>last element</b>. When i is equal to a.length, the condition fails and
            the body is not executed - which is a good thing, because trying to access
            a[a.length] would throw an exception.</p>

            </article>

            <br />
      <header>Array Traversal</header>
      <article>
      <p>Many computations can be implemented by looping through the elements of
        an array and performing an operation on each element. <br><br>For example, the
        following loop squares the elements of a double array:</p>

      <pre><code class="language-java">for (int i = 0; i < a.length; i++) {
    a[i] = Math.pow(a[i], 2.0);
}</code></pre>
     
          <p>Looping through the elements of an array is called a <b>traversal</b>.</p>

          <p>Another common pattern is a <b>search</b>, which involves <b>traversing an array looking for
            a particular element</b>. <br><br>For example, the following method takes an int array
            and an integer value, and it <b>returns the index where the value appears</b>:</p> 

          <pre><code class="language-java">public static int search(double [] a, double target) {
    for (int i = 0; i < a.length; i++) {
        if (a[i] == target) {
            return i;
        }
    }
    return -1;
}</code></pre>

        <p>If we find the target value in the array, we return its index immediately. If the
          loop exits without finding the target, it returns -1, a special value chosen to
          indicate a failed search.</p>

          <p>Another common traversal is a <b>reduce</b> operation, which <b>"reduces" an array
            of values down to a single value</b>. Examples include the sum or product of the
            elements, the minimum, and the maximum. <br><br>The following method takes a
            double array and returns the sum of the elements:</p>

          <pre><code class="language-java">public static double sum (double [] a) {
    double total = 0.0;
    for (int i = 0; i < a.length; i++) {
        total += a[i];
    }
    return total;
}</code></pre>

      <p>Before the loop, we initialize total to zero. Each time through the loop, we
        update total by adding one element from the array. At the end of the loop,
        total contains the sum of the elements. A variable used this way is sometimes
        called an <b>accumulator</b>.</p>

  
            </article>
      <br />
      <header>Random Numbers</header>
      <article>
          <p> We spoke prior about using the Math class method, Math.random() to generate random numbers. How can this be relevant for arrays?</p>

          <p>As previously mentioned, most computer programs do the same thing every time they run; programs like
            that are <b>deterministic</b>. Usually determinism is a good thing, since we expect
            the same calculation to yield the same result. But for some applications, we
            want the computer to be unpredictable. Games are an obvious example, but
            there are many others.</p>

          <p>Making a program <b>nondeterministic</b> turns out to be hard, because it is hard
            for a computer to generate truly random numbers. But there are algorithms
            that generate unpredictable sequences called pseudorandom numbers. For
            most applications, they are as good as random.</p>

          <p>The following code creates an <b>int</b> array and fills it with random numbers
            between 0 and 99, then displays it using the printArray() we just discussed: </p>

          

          <pre><code class="language-java">public static void main (String [] args) {
    final int SIZE = 10;
    int max = 100;
    int min = 1;
    int [] a = new int [SIZE];
    for (int i = 0; i < a.length; i++) {
        int rand = (int) (Math.random() * (max - min) + min);
        a[i] = rand;
    }
    printArray(a);
}</code></pre>

      <p>The output looks something like this:</p>

        <p><b>{99, 47, 18, 51, 86, 55, 21, 88, 50, 67}</b></p>

        <p>If you run it, you will probably get different values.</p>

      </article>
      <br />
      <header>Traverse and Count</header>
      <article>
        <p>If these values were exam scores -- and they would be pretty bad exam scores
          -- the teacher might present them to the class in the form of a histogram. In
          statistics, a histogram is a set of counters that keeps track of the number of
          times each value appears.</p>

         <p>For exam scores, we might have ten counters to keep track of how many
          students scored in the 90s, the 80s, etc. To do that, we can <b>traverse the
          array and count the number of elements that fall in a given range</b>.</p>

        <p>The following method takes an array and two integers, low and high. It
          returns the number of elements that fall in the range from low to high.</p>

        <pre><code class="language-java">public static int inRange (int [] a, int low, int high) {
    int count = 0;
    for (int i = 0; i < a.length; i++) {
        if (a[i] >= low && a[i] < high) {
            count++;
        }
    }
    return count;
}</code></pre>

      <p>This pattern should look familiar: it is another reduce operation. Notice that
        low is included in the range (>=), but high is excluded (<). <b>This detail keeps
        us from counting any scores twice</b>.</p>

      <p>Now we can count the number of scores in each grade range:</p>

      <pre><code class="language-java">public static void main (String [] args) {
    final int SIZE = 10;
    int max = 100;
    int min = 1;
    int [] scores = new int [SIZE];
    for (int i = 0; i < scores.length; i++) {
        int rand = (int) (Math.random() * (max - min) + min);
        scores[i] = rand;
    }
    printArray(scores);

    int a = inRange(scores, 90, 100);
    int b = inRange(scores, 80, 90);
    int c = inRange(scores, 70, 80);
    int d = inRange(scores, 60, 70);
    int f = inRange(scores, 0, 60);
}</code></pre>


        
      </article>
      <br />
      <header>Building a Histogram</header>
      <article>
        <p>The previous code is repetitious, but it is acceptable as long as the number of
          ranges is small. But suppose we wanted to keep track of the number of times each score appears. 
          We would have to write 100 lines of code:</p>

        <pre><code class="language-java">int count0 = inRange(scores, 0, 1);
int count1 = inRange(scores, 1, 2);
int count2 = inRange(scores, 2, 3);
...
int count99 = inRange(scores, 99, 100);</code></pre>

        <p>What we need is a way to store 100 counters, preferably so we can use an
          index to access them. In other words, <b>we need another array!</b></p>

        <p>The following fragment creates an array of 100 counters, one for each possible
          score. It loops through the scores and uses inRange to count how many times
          each score appears. Then it stores the results in the array:</p>

        <pre><code class="language-java">int [] counts = new int [100];
for (int i = 0; i < counts.length; i++) {
    counts[i] = inRange(scores, i, i + 1);
}</code></pre>

        <p>Notice that we are using the loop variable i three times: as an index into
          the counts array, and as two arguments for inRange(). The code works, but
          it is not as efficient as it could be. <b>Every time the loop invokes inRange(), it
          traverses the entire array</b>.</p>

        <p>It would be better <b>to make a single pass through the array, and for each score,
          compute which range it falls in and increment the corresponding counter</b>. This
          code traverses the array of scores only once to generate the histogram:</p>

        <pre><code class="language-java">int [] counts = new int [100];
for (int i = 0; i < scores.length; i++) {
    int index = scores[i];
    counts[index]++;
}</code></pre>

        <p>Each time through the loop, it <b>selects one element from scores and uses it
          as an index to increment the corresponding element of counts</b>. Because this
          code only traverses the array of scores once, it is much more efficient.</p>

        
      </article>
      <br />
      <header>The Enhanced For Loop</header>
      <article>
       <p>Since traversing arrays is so common, <b>Java provides an alternative syntax that
        makes the code more compact</b>. <br><br>For example, consider a for loop that displays
        the elements of an array on separate lines:
        </p>

        <pre><code class="language-java">for (int i = 0; i < values.length; i++) {
    int value = values[i];
    System.out.println(value);
}</code></pre>

        <p>We could rewrite the loop like this:</p>

        <pre><code class="language-java">for (int value : values) {
    System.out.println(value);
}</code></pre>

      <p>This statement is called <b>an enhanced for loop</b> or a <b>for-each loop</b>. <i>You can read it as, "for each
        value in values"</i>. It is conventional to use plural nouns for array variables
        and singular nouns for element variables.</p>

      <p>Notice how the single line <b>for (int value : values)</b>replaces the first two
        lines of the standard for loop. It hides the details of iterating each index of
        the array, and instead, focuses on the values themselves.</p>

      <p>Using the enhanced for loop, and removing the temporary variable, we can
        write the histogram code from the previous section more concisely:</p>

        <pre><code class="language-java">int [] counts = new int[100];
for (int score : scores) {
    counts[score]++;
}</code></pre>

        <p>Enhanced for loops often make the code more readable, especially for accumulating values. 
          <b>But they are not helpful when you need to refer to the index,
          as in search operations</b>.</p>

          <pre><code class="language-java">for (double d : array) {
    if (d == target) {
        // array contains d, but we don't know the index
    }
}</code></pre>
      
      </article>
      <br />
      <header>Passing Arrays as Method Parameters</header>
      <article>
        <p>Passing arrays to methods is similar to passing primitive data types. 
          However, there is one key difference that needs to be kept in mind. <b>Primitive data types
          are considered "pass-by-value"</b> while <b>arrays mimic a concept called "pass-by-reference", 
          meaning that when an array is passed as an argument, its memory address location (its "reference") 
          is used</b>.
          <br><br>When <b>passing a primitive data type as a parameter, you are passing a copy of the data</b>. 
          Therefore, changes made to the data are lost when the method returns unless the data is returned, 
          i.e. the caller and callee have two independent variables with the same value. 
          If the callee modifies the parameter value, the effect is not visible to the caller. 
          <br><br>When <b>passing an array as a parameter you are passing a pointer to the arrays memory location</b>. 
          Therefore, <b>changes made to the array in the method are kept even when the method returns.</b>
          In this way, the contents of an array CAN be changed inside of a method, 
          since we are <b>dealing directly with the actual array and not with a copy of the array</b>.</p>

          <p>⚠️<b>You will need to be careful when sending an array to a method.  Remember that any changes made to the array in the method will change the data in the original array.  
            Be sure that your intention is to change the original data (thus losing the original data)</b>.⚠️</p>

          <p>To pass an array of variables it is identical to passing a single variable with the 
            exception of placing a "[]" between your Variable type and your variable name like so:
            </p>

          <pre><code class="language-java">public static int add(int [] x){}</code></pre>

        <p>The following is a method named add that passes an array as a parameter, calculates the sum of the array elements and returns the sum:</p>

        <pre><code class="language-java">public static int add(int [] x){
    int sum = 0;
    for(int i = 0; i < x.length; i++)
        sum = sum + x[i];
              
    return sum;
} </code></pre>

      <p>Calling the method is exactly the same as if you were sending a single value variable:</p>

      <pre><code class="language-java">int [] x = {1, 2};
int sum = add(x);</code></pre>

        <p>Another example:</p>

        <pre><code class="language-java">public static void main(String [] args) {
    int [] num = {1, 2, 3};
    for(int i = 0; i < num.length; i++){
        System.out.println("num[" + i + "] = " + num[i]);
    }
    
    System.out.println("Now, call the method.");

    testArray(num);// Method call
    for(int j = 0; j < num.length; j++){
      System.out.println("num[" + j + "] = " + num[j]);
  }
}

public static void testArray(int [] value){
    value[0] = 4;
    value[1] = 5;
    value[2] = 6;
}</code></pre>

        <p>What do we expect this code to print?</p>
            
      </article>
    
      <br />
      <header>Partially Filled Arrays</header>
      <article>
        <p>When working with arrays, we will come across situations where some array indexes contain a value, while others do not. 
          These arrays are said to be <b>'partially filled'</b>.</p>
          

          <p>A <b>partially filled array</b> is an array that <b>has indexes that aren't being used to store data</b>. 
            The size of an array is set when it is initialized and cannot be changed afterwards. 
            So, we <b>initialize an array with a size large enough to hold the maximum amount of data that needs to be stored</b>. 
            <br><br>The following image displays what a typical partially filled array looks like. 
            Notice that indexes 4,5,6 and 7 have not been populated by any data. 
            The lack of data in these indexes is what makes this a partially filled array.</p>

            <img style="width: 100%; height: 80%" src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Partially.Filled.Arrays.png?raw=true" alt="distance formula"/>

          <p>Partially filled arrays are normally instantiated using a constant variable that defines the maximum array size (capacity).
             A size variable is created to keep track of the current size of your partially filled array. 
             The size variable also allows you to ensure that you are not exceeding the maximum size. 
            <br><br>For example:</p>

            <pre><code style="font-size: 25px" class="language-java">public static void main(String [] args){
    final int CAPACITY = 100; //determines total size of array
    int [] partialArray = new int[CAPACITY]; 
    int size = 0; //keeps track of the size of partialArray
}</code></pre>

          <p>Handling partially filled arrays is very similar to handling full arrays. 
            The difference is that you must include a size variable and update it when you add and remove data from the array.</p>

          <b><p>To deal with this added complexity, it is important to know how to do two things:</p>
          <ol>
            <li>Define an array index as empty</li>
            <li>Use a Size variable to keep track of the size of your array</li>
          </ol></b>


          <p>The obvious value to choose when determining if an index is empty is the default value that a variable is assigned when the variable is created. 
            Recall that <b>when you create a String variable, its default value is null</b>. 
            Meanwhile, <b>for ints, doubles, and chars, their default values are 0</b>. 
            Lastly, <b>the default value for a boolean variable is false</b>.</p>

          <p>While using the default value may work well in some cases (using the default works well for Strings), 
            <b>the default value will not work for all cases</b>. 
            In particular, using the default value to define the empty index in an array of ints or doubles can usually lead to problems.</p>

          <p>For example, suppose you have a program which stores an assignment mark out of 10 for a group of students in an array of type int. 
            Each index in the array corresponds to one students mark. <b>If you use the default value to define an empty index, 
            it will be impossible to tell the difference between students whose assignments have not been marked, and students who got a mark of 0</b>.</p>

          <p>In order to avoid cases where the default value conflicts with possible array values, <b>you need to initialize the array to something different</b>. 
            <br><br>In the above scenario, the problem of 0 being both an empty index and an input value can be solved by initializing the array index values to -1. 
            The code snippet below shows some example code as to what the initialization code might look like:</p>

          <pre><code style="font-size: 23.5px" class="language-java"> public static void main(String [] args){
    final int TOTAL_STUDENTS = 30;
    int [] gradeArray = new int[TOTAL_STUDENTS];
            
    for(int i = 0; i < gradeArray.length; i++) { //go through all indexes
        gradeArray[i] = -1; //set each index to -1
    }
} </code></pre>

          <p>While initializing the array index values to -1 works well in the assignment mark example, 
            it obviously wouldn't work if -1 was a valid input value. 
            However, in the above example, we are following a more general rule: 
            <b>always define your empty index such that it can not be mistaken for a valid input value</b>.</p>

            <p>Most programs will have a separate method for adding and deleting data from a partially filled array. You will need to pass the size variable anytime you need to access the contents of partialArray. When working with a partially filled array where array values are added and removed, your array may fill up to maximum capacity. 
              By comparing the size and CAPACITY variables, you can quickly determine if new values can be added to the array.</p>

              <p>For example, we can insert data by first checking whether or not we have met the capacity of the array:</p>

              <pre><code style="font-size: 21.5px" class="language-java">public static void insert(int [] partialArray, int size){
    if (size < partialArray.length) { //check to ensure size is less than capacity
        partialArray[size] = 50; //or whatever value needs to be added here
        size++; //increase the # of values in array
    }
}</code></pre>

    <p>The same logic can be applied to removing something from the END of the data list:</p>

<pre><code style="font-size: 21.5px" class="language-java">public static void delete(int [] partialArray, int size){
    if (size > 0){
        partialArray[size-1] = 0;  // size-1 is the last index containing data
        size--;
    }
}</code></pre>
      </article>

      <br />
      <header>Removing an Element from the Array</header>
      <article>
        <p>We just talked about removing an element from the end of our data list, but what if we needed to 
          remove an element from the middle of the array?</p>

        <p>What does it mean to <i>remove</i> an element from an array? 
          The problem with Java arrays (and arrays in many languages) is the array <b>is fixed in length</b>. 
          This means you can't easily remove elements from an array.</p>

        <p>However we can shift elements, which for our purposes is almost the same.</p>

        <p><b>To remove an array element at index i, you shift elements with index greater than i left 
          (or down) by one element</b>. For example, if you want to remove element 3, 
          you copy element 4 to element 3, element 5 to element 4, element 6 to element 5, ... etc.</p>

        <p>In other words, you copy element j + 1 to element j, where j ranges from i 
          (which is the element we want to remove) up to the length of the array minus 2. 
          (Minus 2? Why 2? We'll see soon).</p>

          <p>This way we preserve the "order" of the array. <br><br>For example, think of the array as a line of students waiting to get tickets to an event.
            Suppose one student leaves the line. We can think of the student being "removed" from the line. 
            When this student is removed, all of the students behind should move up one step. 
            For example, if the student standing 3rd in line leaves, then the student that's 4th in line becomes 3rd. The one that's 5th in line becomes 4th, and so forth.</p>

        <p>Let's say we have a roster of students waitlisted for a particular class and we want to remove a specific student from the middle of the roster (let's say they are no longer interested).
           <b>We can achieve this by first finding the index of the student we want to remove and then using that index to remove the student from the roster</b>.</p>
      
        <pre><code class="language-java">String [] roster = {"Alice", "Bob", "Charlie", "David", "Eve"};</code></pre>

        <p>We can treat <b>index 0 as the front of the line and the index, 
          length - 1, as the end of the line</b>. Once we identify the student who has left the waitlist, let's say Charlie, 
          we can find their location using a searching algorithm (in this case, Charlie is located at index 2)</p>

          <p>We can now start shifting up from that index (not from the beginning as indexes 0 and 1 are not affected by this modification):</p>

        <pre><code class="language-java">public static void removeElt(int [] arr, int remIndex){
    for(int i = remIndex; i < arr.length - 1; i++){
        arr[i] = arr[i + 1] ; 
    }
}</code></pre>

        <p>Notice that we used <b>arr.length - 1</b> instead of arr.length. Why?<br><br>
          What's the maximum value that i reaches, but where the condition still evaluates to true? 
          <br><br><b>Answer: the maximum value of i where we still enter the loop body is arr.length - 2</b>.</p>


          <p>Let's plug in <b>arr.length - 2</b> for <b>i</b> and see what happens. This is basically what happens on the last iteration of the loop:</p>

          <pre><code class="language-java">arr[arr.length - 2] = arr[(arr.length - 2) + 1];</code></pre>

        <p>which is just:</p>

        <pre><code class="language-java">arr[arr.length - 2] = arr[arr.length - 1];</code></pre>

        <p>This is a valid assignment. We are copying the <b>last element of the array (i.e., element arr.length - 1)</b> 
          to the <b>next to last element (i.e., element arr.length - 2)</b>.</p>

 
        <p>You'll notice that the students each get shifted to the left by 1 starting from "David" replacing "Charlie". 
          However, the last element is still "Eve" (there are now two "Eve"s!).
          <br><br>
          This kind of removing leaves the last element (i.e., the element at the maximum index) unchanged.
          <br><br>
          Is that OK? Usually, it's fine. 
          You might be tempted to set it to <b>0</b> (if numerical) or <b>null</b> (in our case, Strings)
           or some other value, but if there's no compelling reason to do so, you can leave it alone.
          <br><br>
          However, for this case, to avoid duplicate students <b>we should set the last element to null 
          and keep track of how many students are actually on the list (making it a partially filled array)</b>.
          </p>

      </article>
      <br />
      <header>Parallel Arrays</header>
      <article>
        <p>Sometimes we need multiple types of data that all apply to the same particular record. 
          Think of a spreadsheet containing student names and test scores.</p>

        <p>Despite being separate data (student names and numerical test scores respectively), 
          a pair of them can both be attributed to the same person (they are not independent of one another)</p>

          <pre><code class="language-java">int [] highScores = {99,98,98,88,68};
String [] names = {"Jamal", "Emily", "Destiny", "Mateo", "Sofia"};</code></pre>

          <img style="width: 100%; height: 100%"
          src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/intAndStringArrays.png?raw=true"
          alt="Parallel Arrays">

          <p>The data type of the arrays themselves do not need to match (as one is String and one is int)
            However, to be <b>parallel</b> they do <b>need to be both of the same size</b> (every student has a corresponding grade)
          </p>

          <p><b>Parallel arrays are several arrays with the same number of elements that work in 
            tandem to organize data</b>.</p>

          <p>Parallel arrays come in handy <b>when data regarding different characteristics of the 
            same subject of interest needs to be stored and accessed efficiently</b>.</p>

        <p>Let's look at the following arrays representing the data from a dog show:</p>
          <pre><code style="font-size: 24px" class="language-java">String [] dogName = {"Wally", "Skeeter", "Corky", "Jessie", "Sadie"};
int [] round1 = {18,22,12,17,15};
int [] round2 = {20,25,16,18,17};</code></pre>

        <p>In the data represented above, the first array is the dog's name, 
          the second array is the dog's score in round 1 of the competition, 
          and the third array is the dog's score in round 2 of the competition.  
          The dog in the first element of the first array 
          has the scores represented in the first elements of the second and third arrays.
          Notice that the arrays do not all contain the same "type" of data
          Such data, can be stored using <b>parallel arrays</b>.</p>  
        
          <p>Now we can print out the arrays:</p>

          <pre><code style="font-size: 22px" class="language-java">//Printing the dog competition information:
for(int index = 0; index < dogname.length; index++){
    System.out.print("Contestant #" + (index+1) + ": " + dogName[index] + " ");
    System.out.print("Round 1: " + round1[index] + " ");
    System.out.print("Round 2: " + round2[index] + " ");
    System.out.println("Total score: " + (round1[index]+round2[index]));
}</code></pre>
            
      <p>Another example: The program below implements <b>four parallel arrays</b>. 
        The <b>first, second, third, and fourth arrays</b> store the <b>names, ages, grades, 
        and the subjects of five students</b>, respectively.</p>

        <p>Due to the semantics of parallel arrays, <b>each array is of the same size</b>, 
          and <b>each array element at the same index in all four arrays corresponds to the same student</b>, 
          who will be our subject of interest.</p>

        <p>Using one for loop, all characteristics of each student are accessed and printed:</p>

        <pre><code style="font-size: 22px" class="language-java">String [] fname = {"John", "Michael", "Sara", "Zubair", "Sadia"};
int [] age = {18,19,18,19,19};
char [] grade = {'B','A','B','A','A'};
String [] subject =  {"English", "Math", "History", "Physics", "Chemistry"};
for (int i = 0; i < fname.length; i++) {
  System.out.print("My name is " + fname[i] + ". I am " + age[i]);
  System.out.print(" years old. I have a grade of " + grade[i]); 
  System.out.println(" in my favorite subject: " + subject[i] + "!");
}</code></pre>





      </article>
      <br />
      <header>Searching Arrays</header>
      <article>
        <p>We spoke a bit about searching arrays so far, and we have always done it like this:</p>

        <pre><code class="language-java">public static int search(String [] roster, String student) {
    for (int i = 0; i < roster.length; i++) {
        if (roster[i].equals(student)) {
            return i;
        }
    }
    return -1;
}</code></pre>

      <p> This version of search uses the algorithm we are most familiar with, 
        which is called <b>linear (sequential) search</b></p>

        <p><b>Linear Search</b> is defined as a <b>sequential search algorithm</b> that <b>starts at one end 
          and goes through each element of a list until the desired element is found, 
          otherwise the search continues till the end of the data set</b>.</p>

        <p>In the Linear Search Algorithm:</p>
        <ul>
          <li>Every element is considered as a potential match for the key and checked for the same</li>
          <li>If any element is found equal to the key, the search is successful and the index of that element is returned</li>
          <li>If no element is found equal to the key, the search yields “No match found”</li>
        </ul>

        <p>We can define the algorithm with four main steps:</p>
        <b><ol>
          <li>Traverse the array</li>
          <li>Match the key element with array element</li>
          <li>If key element is found, return the index position of the array element</li>
          <li>If key element is not found, return -1</li>
        </ol></b>

        <p>For example: Consider the array <b>int [] arr = {10, 50, 30, 70, 80, 20, 90, 40}</b> 
          and <b>key (the element we are searching for) = 30</b></p>

          <p>We will start searching from the first element (index 0) and compare the key with each element (arr[i])</p>

          <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Linear-search-algorithm-1.png?raw=true"
            alt="Linear Search 1">

          <p>Comparing the key with first element arr[0]. 
            Since they are not equal, the iterator moves to the next element as a potential match.</p>

            <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Linear-search-algorithm-2.png?raw=true"
            alt="Linear Search 2">

          <p>Comparing key with next element arr[1]. 
            Since they are also not equal, the iterator moves to the next element as a potential match.</p>

            <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/Linear-search-algorithm-3.png?raw=true"
            alt="Linear Search 3">

          <p>Now when comparing arr[2] with key, the value matches.<br><br>
            So the Linear Search Algorithm will yield a successful message and 
            return the index of the element when key is found (here 2).</p>


      <p><b>If the array elements are not in order, there is no way to search faster than 
        linear/sequential search</b>. We have to look at every element, because otherwise we cannot
        be certain the element we want is not there. But if the elements are in order, we can
        use better algorithms!</p>

        <p>When we look for a word in a dictionary, we don't just search page by page
          from front to back. <br><br>Since the words are in alphabetical order, you probably want to
          use a <b>binary search algorithm</b>:
          </p>
          <ol>
            <li>Start on a page near the middle of the dictionary.</li>
            <li>Compare a word on the page to the word you are looking for. If you find
              it, stop.</li>
            <li>If the word on the page comes before the word you are looking for, flip
              to somewhere later in the dictionary and go to step 2.</li>
            <li>If the word on the page comes after the word you are looking for, flip to
              somewhere earlier in the dictionary and go to step 2.</li>
          </ol>

          <p>If you find two adjacent words on the page and your word comes between
            them, you can conclude that your word is not in the dictionary.</p>

            <p><b>Binary Search</b> is defined as a searching algorithm 
              <b>used in a sorted array by repeatedly dividing the search interval in half</b>.</p>

            <p>Getting back to our previous example of a roster of students, we can write a faster version of search if
              we know the students are in order (and they usually are!):</p>

              <pre><code class="language-java">public static int binarySearch(String [] roster, String student) {
    int low = 0;
    int high = roster.length - 1;
    while (low <= high) {
        int mid = (low + high) / 2; // step 1
        int comp = roster[mid].compareTo(student);
        if (comp == 0) { // step 2
            return mid;
        } else if (comp < 0) { // step 3
            low = mid + 1;
        } else { // step 4
            high = mid - 1;
        }
    }
    return -1;
}</code></pre>
     
<p>This version is called iterative as the approach iterates through the array.</p>

    <p>First, we declare <b>low</b> and <b>high</b> variables to represent the range we are searching. 
      Initially we search the entire array, from 0 to length - 1.</p>

    <p>Inside the <b>while</b> loop, we repeat the four steps of binary search:</p>

    <b><ol>
      <li>Choose an index between low and high – call it mid – and compare the
        student name at mid to the target.</li>
      <li>If you found the target, return the index.</li>
      <li>If the name at mid is lower than the target (lexicographically before), search the range from mid + 1
        to high</li>
      <li>If the name at mid is higher than the target (lexicographically after), search the range from low
        to mid - 1.</li>
    </ol></b>

    <p><b>If low exceeds high, there are no Strings in the range, so we break out of the
      loop and return -1</b>. Notice that this algorithm depends on the String .compareTo()
      method.</p>

    <p>We can also write this algorithm recursively (the technique of making a method/function call itself):</p>

    <pre><code style="font-size: 20px" class="language-java">public static int binarySearch(String [] roster, int low, int high, String student) {
    if (high >= low) {
        int mid = low + (high - low) / 2;
  
        int comp = roster[mid].compareTo(student);
        if (comp == 0)
            return mid;
  
        if (comp < 0)
            return binarySearch(arr, mid + 1, high, x);
        
        return binarySearch(arr, low, mid - 1, x);
      }
  
    return -1;
}</code></pre>

      <p>Let's look at another example:</p>

      <p>Consider an array <b>int [] arr2 = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}</b>, and the <b>key/target = 23</b>.</p>

      <p>The first step: <b>Calculate the mid and compare the mid element with the key. If the key is less than mid element, 
        move to left and if it is greater than the mid then move search space to the right</b>.</p>

        <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/binary-search-1.png?raw=true"
            alt="Binary Search 1">

        <p>Key (i.e., 23) is greater than current mid element (i.e., 16). The search space moves to the right.</p>
          
        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/binary-search-2.png?raw=true"
        alt="Binary Search 2">

        <p>Key is less than the current mid 56. The search space moves to the left.</p>

       <p>The second step: <b>If the key matches the value of the mid element, 
        the element is found and stop search</b>.</p>

            <img style="width: 100%; height: 100%"
            src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/binary-search-3.png?raw=true"
            alt="Binary Search 3">
     
      </article>
     <br />
      <header>Sorting Algorithms</header>
      <article>
        <p>Sometimes data needs to be arranged in a specific order so it's easier to understand, search, and process.
          We call this process sorting.<br><br>
          <b>Sorting</b> refers to <b>arranging data in a specific order using certain criteria</b>. 
          You can sort different types of data, including numbers, strings, and objects</p>

          <p>Because sorting arrays requires exchanging values, computers must use a special technique to swap the positions of array elements so as not to lose any elements.</p>

          <p>Suppose that grade[1] = 10 and grade[2] = 8 and you want to exchange their values so that grade[1] = 8 and grade[2] = 10.</p>

          <p>You CANNOT just do this:</p>

          <pre><code class="language-java">grade[1] = grade[2];
grade[2] = grade[1]; //Does NOT Work!!</code></pre>

          <p>In the first line, the value of grade[1] is erased and replaced with grade[2]. 
            The result is that both grade[1] and grade[2] now have the same value.<br><br>
            In order to swap two values, you must use a third variable (a "temporary holding variable"), to temporarily hold the value you do not want to lose:</p>

          <pre><code class="language-java">//swapping variables 
temp = grade[1];  //holding variable
grade[1] = grade[2];
grade[2] = temp;</code></pre>

            <p>This process successfully exchanges ("swaps") the values of the two variables, without the loss of any values.
              <br><br>There are many different ways to sort arrays. The basic goal of each method is to compare each array element to another array element and swap them if they are in the wrong position. 
              </p>

          <p>The two algorithms that most beginners start their sorting career with would be <b>bubble sort</b> and 
            <b>selection sort</b>. These sorting algorithms are not very efficient, but they provide a key 
            insight into what sorting is and how a sorting algorithm works behind the scenes.
            </p>

            <p>In the <b>bubble sort</b>, as elements are sorted they gradually "bubble" (or rise) to their proper location in the array, like bubbles rising in a glass of soda.</p>

          <p><b>Bubble sort</b> relies on multiple swaps (unlike selection sort which only uses one). 
            The algorithm <b>continues to go through the array repeatedly, swapping elements that 
            are not in their correct location</b>.</p>  

          <p>Algorithm:</p>
          <ol>
            <li>START</li>
            <li>Run two loops – an inner loop and an outer loop.</li>
            <li>Repeat steps till the outer loop are exhausted.</li>
            <li>If the current element in the inner loop is smaller than its next element, swap the values of the two elements.</li>
            <li>END</li>
          </ol> 

          <p>The following is the syntax for a simple bubble sort (in descending order): </p>

          <pre><code class="language-java" style="font-size: 23px">public static void bubbleSort(int [] x, int n) {
    int hold, j, pass;
    boolean switched = true;
            
    for (pass = 0; pass < n - 1 && switched; pass++) {
        //outer loop controls the number of passes
        switched = false;// initially no interchanges have been
        // made one this pass
        for (j = 0; j < n - pass - 1; j++) {
            // inner loop governs each individual pass
            if (x[j] > x[j + 1]) {
            // elements are out of order an interchange is necessary
                switched = true;
                hold = x[j];
                x[j] = x[j + 1];
                x[j + 1] = hold;
            } // end if
        } // end for (j = 0 …
    } // end for (pass = 0 ...
} // end bubbleSort method</code></pre>

        <p>Let's see how this works visually. Let's start with <b>int [] arr = {6, 0, 3, 5};</b>:</p>

        <p>During our first pass: <b>The largest element is placed in its correct position, i.e., the end of the array.</b></p>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/bubble%20sort%201.png?raw=true"
        alt="Bubble sort 1">

        <p>During our second pass: <b>we place the second largest element at correct position.</b></p>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/bubble%20sort%202.png?raw=true"
        alt="Bubble sort 2">

        <p>During our third pass: <b>we place the remaining two elements at their correct positions and all the elements are in order.</b></p>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/bubble%20sort%203.png?raw=true"
        alt="Bubble sort 3">

        <p>We can see that the <b>total number of passes required is n-1</b> and the <b>total number of comparisons is 
          n*(n-1)/2</b> where n is the total number of elements.</p>

        <p>The bubble sort is an easy algorithm to program, but it is slower than many other sorts.</p>

        <p>With a bubble sort, it is always necessary to make one final "pass" through the array to check to see that no swaps are made to ensure that the process is finished. 
          In actuality, the process is finished before this last pass is made.</p>

          <p><b>The time complexity of Bubble Sort is O(N^2)</b>.</p>
  
          <p><b>Advantages of the Bubble Sort Algorithm:</b></p>
          <ul>
            <li>Bubble sort is easy to understand and implement.</li>
            <li>It does not require any additional memory space.</li>
            <li>It is a stable sorting algorithm, meaning that elements with the same key value 
              maintain their relative order in the sorted output.</li>
          </ul>
  
          <p><b>Disadvantages of the Bubble Sort Algorithm:</b></p>
          <ul>
            <li>Bubble sort has a time complexity of O(N2) which makes it very slow for large data sets.</li>
            <li>Bubble sort is a comparison-based sorting algorithm, which means that it requires a comparison operator to determine the relative order of elements in the input data set. 
              It can limit the efficiency of the algorithm in certain cases.</li>
          </ul>

        <p>On the otherhand, <b>selection sort</b> repeatedly selects the smallest (or largest) element from the unsorted portion of the list and swaps it with the first element of the unsorted part. 
          This process is repeated for the remaining unsorted portion until the entire list is sorted. </p>
        
          <p>The following is the syntax for a simple selection sort (in ascending order): </p>

          <pre><code class="language-java" style="font-size: 23px">public static void selectionSort(int [] x, int n) {
    // One by one move boundary of unsorted subarray
    for (int i = 0; i < n - 1; i++) {
        // Find the minimum element in unsorted array
        int min_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        // Swap the found minimum element with the first element
        int temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}</code></pre>

      <p>Let's take a look at the following example, where <b>int [] arr = {64, 25, 12, 22, 11};</b>:</p>

      <p>During the first pass:</p>
      <ul>
        <li>For the first position in the sorted array, the whole array is traversed from index 0 to 4 sequentially. The first position where 64 is stored presently, 
          after traversing whole array it is clear that 11 is the lowest value.</li>
        <li>Thus, replace 64 with 11. After one iteration 11, which happens to be the least value in the array, tends to appear in the first position of the sorted list.</li>
      </ul>

      <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/selection%20sort%201.png?raw=true"
        alt="Selection sort 1">

        <p>During the second pass:</p>
      <ul>
        <li>For the second position, where 25 is present, again traverse the rest of the array in a sequential manner.</li>
        <li>After traversing, we found that 12 is the second lowest value in the array and it should appear at the second place in the array, thus swap these values.</li>
      </ul>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/selection%20sort%202.png?raw=true"
        alt="Selection sort 2">

        <p>During the third pass:</p>
      <ul>
        <li>Now, for third place, where 25 is present again traverse the rest of the array and find the third least value present in the array.</li>
        <li>While traversing, 22 came out to be the third least value and it should appear at the third place in the array, thus swap 22 with element present at third position.</li>
      </ul>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/selection%20sort%203.png?raw=true"
        alt="Selection sort 3">

        <p>During the fourth pass:</p>
      <ul>
        <li>Similarly, for fourth position traverse the rest of the array and find the fourth least element in the array.</li>
        <li>As 25 is the 4th lowest value hence, it will place at the fourth position.</li>
      </ul>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/selection%20sort%204.png?raw=true"
        alt="Selection sort 4">

        <p>During the fifth pass:</p>
      <ul>
        <li>At last the largest value present in the array automatically get placed at the last position in the array.</li>
        <li>The resulted array is the sorted array.</li>
      </ul>

        <img style="width: 100%; height: 100%"
        src="https://github.com/amaraauguste/amaraauguste.github.io/blob/master/courses/CISC1115/images/selection%20sort%205.png?raw=true"
        alt="Selection sort 5">
            
        <p><b>The time complexity of Selection Sort is O(N^2)</b> (the same as bubble sort) 
          as there are two nested loops:</p>

        <ul>
          <li>One loop to select an element of Array one by one = O(N)</li>
          <li>Another loop to compare that element with every other Array element = O(N)</li>
          <li>Therefore overall complexity = O(N) * O(N) = O(N*N) = O(N^2)</li>
        </ul>

        <p><b>Advantages of the Selection Sort Algorithm:</b></p>
        <ul>
          <li>Simple and easy to understand.</li>
          <li>Works well with small datasets.</li>
        </ul>

        <p><b>Disadvantages of the Selection Sort Algorithm:</b></p>
        <ul>
          <li>Selection sort has a time complexity of O(n^2) in the worst and average case.</li>
          <li>Does not work well on large datasets.</li>
          <li>Does not preserve the relative order of items with equal keys which means it is not stable.</li>
        </ul>



      </article>
    
      <br />
      <hr />
    </section>


















































































    <section class="main-section" id="Reference">
      <br />
      <header><b>Reference</b></header>
      <article>
        <p>Documentation on this page is taken from the following:</p>
        <ul>
          <li>Allen Downey and Chris Mayfield, <i><b>Think Java: How to Think Like a Computer Scientist</b></i>, 2nd
            Edition, Version 7.1.0, Green Tea Press, 2020, Creative Commons License.
          </li>
          <br>
          <li>
            <a href="https://www.geeksforgeeks.org/introduction-to-java/" target="_blank">GeeksforGeeks</a>
          </li>
          <br>
          <li>
            <a href="https://www.programiz.com/java-programming" target="_blank">Programiz</a>
          </li>
          <br>
          <li>
            <a href="https://ioflood.com/blog/java-char/" target="_blank">IOFLOOD</a>
          </li>
        </ul>
      </article>
    </section>
  </main>
</body>
</html>

</html>
